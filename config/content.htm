<h1>歡迎歡迎</h1>
<p>可攜程式套件:<a href="http://229.cycu.org/portable_2026.7z">portable_2026.7z</a> </p>
<p>個人github:<a href="https://github.com/LanChienEn/w11">https://github.com/LanChienEn/w11</a></p>
<p style="padding-left: 60px;"></p>
<p></p>
<h1>Brython指令區</h1>
<p><button id="add1to100">1 add to 100</button><button id="robot1">機器人巡邏</button><button id="free_walk">自由行</button></p>
<!-- 導入 brython 程式庫 -->
<p>
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
</p>
<!-- 啟動 Brython -->
<p>
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/','./../downloads/py/']});
}
</script>
</p>
<p><!-- 導入 FileSaver 與 filereader --></p>
<p>
<script src="/static/ace/FileSaver.min.js" type="text/javascript"></script>
<script src="/static/ace/filereader.js" type="text/javascript"></script>
</p>
<p><!-- 導入 ace --></p>
<p>
<script src="/static/ace/ace.js" type="text/javascript"></script>
<script src="/static/ace/ext-language_tools.js" type="text/javascript"></script>
<script src="/static/ace/mode-python3.js" type="text/javascript"></script>
<script src="/static/ace/snippets/python.js" type="text/javascript"></script>
</p>
<p><!-- 導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫 -->
<script src="/static/Cango-24v03-min.js"></script>
<script src="/static/gearUtils-09.js"></script>
<script src="/static/SVGpathUtils-6v03-min.js"></script>
<script src="/static/sylvester.js"></script>
<script src="/static/PrairieDraw.js"></script>
</p>
<p><!-- 請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--></p>
<p>
<script type="text/javascript">
function doSave(storage_id, filename){
    var blob = new Blob([localStorage[storage_id]], {type: "text/plain;charset=utf-8"});
    filename = document.getElementById(filename).value
    saveAs(blob, filename+".py");
}
</script>
</p>
<p><!-- 累加程式開始 -->
<script type="text/python3">
from browser import document as doc
import ace
# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()
Ace1 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )
# 從 gist 取出程式碼後, 放入 editor 作為 default 程式
def run1():
    # 利用 get 取下 src 變數值
    try:
        url = doc.query["src"]
    except:
        url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c3a6deaf717f8f2739a4b1392a5ab10936e9693a/from_1_add_to_10_1.py"
    prog = open(url).read()

    # 將程式載入編輯區
    Ace1.editor.setValue(prog)
    Ace1.editor.scrollToRow(0)
    Ace1.editor.gotoLine(0)
    # 直接執行程式
    #ns = {'__name__':'__main__'}
    #exec(prog, ns)
    # 按下 run 按鈕
    Ace1.run()
# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run1'].bind('click', Ace1.run)
doc['kw_show_console1'].bind('click', Ace1.show_console)
doc['kw_clear_console1'].bind('click', Ace1.clear_console)
doc['clear_bd1'].bind('click', clear_bd1)
# 呼叫函式執行
run1()
</script>
<!-- 累加程式結束 --> <!-- 機器人巡邏程式開始 -->
<script type="text/python3">
from browser import document as doc
import ace

# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()

# 利用 ace 中的 Editor 建立 Ace2 物件, 其中的輸入變數分別對應到頁面中的編輯區物件
Ace2 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )

robot1_url = "https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/b33c5fc2a0774f8c5d2b0e8c7c7908e58d73bb94/robot_1.py"

# 從 gist 取得程式碼
robot1_src = open(robot1_url).read()
def robot1(ev):
    Ace2.editor.setValue(robot1_src)
    Ace2.editor.scrollToRow(0)
    Ace2.editor.gotoLine(0)
    Ace2.run()

# id 為 "robot1" 的按鈕點按時, 執行 robot1 方法
doc["robot1"].bind('click', robot1)
</script>
<!-- 機器人巡邏程式結束 --></p>
<!-- 機器人自由行程式開始 -->
<p>
<script type="text/python3">
from browser import document as doc
import ace

# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()

# 利用 ace 中的 Editor 建立 Ace2 物件, 其中的輸入變數分別對應到頁面中的編輯區物件
Ace2 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )

free_walk_url = "https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/9d55811467e411eb89f74171d8a586ae9f1a96aa/brython_robot_free_walk.py"

# 從 gist 取得程式碼
free_walk_src = open(free_walk_url).read()
def free_walk(ev):
    Ace2.editor.setValue(free_walk_src)
    Ace2.editor.scrollToRow(0)
    Ace2.editor.gotoLine(0)
    Ace2.run()

# id 為 "free_walk" 的按鈕點按時, 執行 robot1 方法
doc["free_walk"].bind('click', free_walk)
</script>
</p>
<!-- 機器人自由行程式結束 -->
<p><!-- add 1 to 100 開始 -->
<script type="text/python3">
from browser import document as doc
import ace

# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()

# 利用 ace 中的 Editor 建立 Ace2 物件, 其中的輸入變數分別對應到頁面中的編輯區物件
Ace2 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )

add1to100_url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c48e37714f055c3a0027cbfef59e442a6ef659b9/from_1_add_to_100_1.py"

# 從 gist 取得程式碼
add_src = open(add1to100_url).read()
def add(ev):
    Ace2.editor.setValue(add_src)
    Ace2.editor.scrollToRow(0)
    Ace2.editor.gotoLine(0)
    Ace2.run()

# id 為 "add1to100" 的按鈕點按時, 執行 add 方法
doc["add1to100"].bind('click', add)
</script>
</p>
<p><!-- add 1 to 100 結束--></p>
<!-- editor1 開始 -->
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor1" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<p><!-- 存擋表單開始 --></p>
<form><label>Filename: <input id="kw_filename" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src1', 'kw_filename1');" type="submit" value="Save"/></form>
<p><!-- 存擋表單結束 --></p>
<p></p>
<p><!-- 執行與清除按鈕開始 --></p>
<p><button id="kw_run1">Run</button> <button id="kw_show_console1">Output</button> <button id="kw_clear_console1">清除輸出區</button><button id="clear_bd1">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<p><!-- 執行與清除按鈕結束 --></p>
<p></p>
<p><!-- 程式執行 ouput 區 --></p>
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console1"></textarea></div>
<p><!-- Brython 程式執行的結果, 都以 brython_div1 作為切入位置 --></p>
<div id="brython_div1"></div>
<!-- editor1 結束 --><hr/><!-- ########################################## -->
<p>從 1 累加到 100 part2:</p>
<p><button id="add1to100part2">1 add to 100</button><button id="cango_three_gears">cango_three_gears</button><button id="bsnake">BSnake</button><button id="aitetris">AI Tetris</button></p>
<p><!-- 請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--></p>
<p>
<script type="text/python3">
from browser import document as doc
import ace
# 清除畫布
def clear_bd2(ev):
    bd = doc["brython_div2"]
    bd.clear()
Ace3 = ace.Editor(editor_id="kw_editor2", console_id="kw_console2", container_id="kw__container2", storage_id="kw_py_src2" )
# 從 gist 取出程式碼後, 放入 editor 作為 default 程式
def run2():
    # 利用 get 取下 src 變數值
    try:
        url = doc.query["src2"]
    except:
        url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c3a6deaf717f8f2739a4b1392a5ab10936e9693a/from_1_add_to_10_1.py"
    prog = open(url).read()

    # 將程式載入編輯區
    Ace3.editor.setValue(prog)
    Ace3.editor.scrollToRow(0)
    Ace3.editor.gotoLine(0)
    # 直接執行程式
    #ns = {'__name__':'__main__'}
    #exec(prog, ns)
    # 按下 run 按鈕
    Ace3.run()

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run2'].bind('click', Ace3.run)
doc['kw_show_console2'].bind('click', Ace3.show_console)
doc['kw_clear_console2'].bind('click', Ace3.clear_console)
doc['clear_bd2'].bind('click', clear_bd2)
# 呼叫函式執行
run2()
</script>
</p>
<p><!-- add 1 to 100 part2 開始 -->
<script type="text/python3">
from browser import document as doc
import ace

# 清除畫布
def clear_bd2(ev):
    bd = doc["brython_div2"]
    bd.clear()

# 利用 ace 中的 Editor 建立 Ace2 物件, 其中的輸入變數分別對應到頁面中的編輯區物件
Ace4 = ace.Editor(editor_id="kw_editor2", console_id="kw_console2", container_id="kw__container2", storage_id="kw_py_src2" )

# 透過 Ace4 以類別建立一個通用的 button2, 可以在多個案例中將 gist 程導入編輯區

class button2:
    def __init__(self, url):
        self.url = url

    # 記得加入 event 輸入變數
    def do(self,ev):
        Ace4.editor.setValue(open(self.url).read())
        Ace4.editor.scrollToRow(0)
        Ace4.editor.gotoLine(0)
        Ace4.run()

add1to100_url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c48e37714f055c3a0027cbfef59e442a6ef659b9/from_1_add_to_100_1.py"

# 從 gist 取得程式碼
add_src = open(add1to100_url).read()
def add2(ev):
    Ace4.editor.setValue(add_src)
    Ace4.editor.scrollToRow(0)
    Ace4.editor.gotoLine(0)
    Ace4.run()

# id 為 "add1to100part2" 的按鈕點按時, 執行 add 方法
doc["add1to100part2"].bind('click', add2)
# 以下為運用 button2 class 的通用 gist 程式導入區
################################## cango_three_gears start
cango_three_gears_url = "https://gist.githubusercontent.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d/raw/f7a85d737d6723d5e34c526d5daee990ed92c32b/cango_three_gears_brython_div2.py"
cango_three_gears = button2(cango_three_gears_url)
doc["cango_three_gears"].bind("click", cango_three_gears.do)
################################## cango_three_gears end
################################## bsnake start
bsnake_url = "https://gist.githubusercontent.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d/raw/f7a85d737d6723d5e34c526d5daee990ed92c32b/kmol_snakey.py"
bsnake = button2(bsnake_url)
doc["bsnake"].bind("click", bsnake.do)
################################## bsnake end
################################## aitetris start
aitetris_url = "https://gist.githubusercontent.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d/raw/f7a85d737d6723d5e34c526d5daee990ed92c32b/pygame_to_brython_tetris_ai.py"
aitetris = button2(aitetris_url)
doc["aitetris"].bind("click", aitetris.do)
################################## aitetris end
</script>
</p>
<p><!-- add 1 to 100 part2 結束--></p>
<!-- editor2 開始 -->
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor2" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<p><!-- 存擋表單開始 --></p>
<form><label>Filename: <input id="kw_filename2" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src2', 'kw_filename2');" type="submit" value="Save"/></form>
<p><!-- 存擋表單結束 --></p>
<p></p>
<p><!-- 執行與清除按鈕開始 --></p>
<p><button id="kw_run2">Run</button> <button id="kw_show_console2">Output</button> <button id="kw_clear_console2">清除輸出區</button><button id="clear_bd2">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<p><!-- 執行與清除按鈕結束 --></p>
<p></p>
<p><!-- 程式執行 ouput 區 --></p>
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console2"></textarea></div>
<p><!-- Brython 程式執行的結果, 都以 brython_div1 作為切入位置 --></p>
<div id="brython_div2"></div>
<!-- editor2 結束 --><hr/>
<p></p>
<h2>Brython</h2>
<p><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/9d55811467e411eb89f74171d8a586ae9f1a96aa/brython_robot_free_walk.py">機器人自由行</a></p>
<p>Can we bring pythonpad into this page? <a href="https://pythonpad.github.io/docs/manual.html">https://pythonpad.github.io/docs/manual.html</a> </p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from browser import document, html, timer
 
canvas = html.CANVAS(width=400, height=400)
brython_div = document["brython_div1"]
brython_div &lt;= canvas
ctx = canvas.getContext("2d")
 
def draw_grid():
    ctx.clearRect(0, 0, 400, 400)
    ctx.strokeStyle = "#ccc"
    ctx.lineWidth = 1
    for i in range(0, 401, 40):
        ctx.beginPath()
        ctx.moveTo(i, 0)
        ctx.lineTo(i, 400)
        ctx.stroke()
        ctx.beginPath()
        ctx.moveTo(0, i)
        ctx.lineTo(400, i)
        ctx.stroke()
    
    # 畫出邊界
    ctx.strokeStyle = "black"
    ctx.lineWidth = 2
    ctx.strokeRect(0, 0, 400, 400)

def draw_robot(x, y):
    draw_grid()
    ctx.fillStyle = "blue"
    ctx.beginPath()
    ctx.arc(x * 40 + 20, y * 40 + 20, 15, 0, 6.28)
    ctx.fill()

x, y = 0, 0
def move():
    global x
    x = (x + 1) % 10
    draw_robot(x, y)

draw_grid()
timer.set_interval(move, 500)</pre>
<p>以下程式, 按 j 隨箭頭方向前進, 按下 i 則左轉</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from browser import document, html, bind

canvas = html.CANVAS(width=400, height=400)
brython_div = document["brython_div1"]
brython_div &lt;= canvas
ctx = canvas.getContext("2d")

cols, rows = 10, 10
cell = 40

# 上、右、下、左
directions = [(0, -1), (1, 0), (0, 1), (-1, 0)]

robot = {
    "x": 5,
    "y": 5,
    "dir": 0  # 初始朝向上
}

def draw_grid():
    ctx.clearRect(0, 0, 400, 400)
    ctx.strokeStyle = "#ccc"
    ctx.lineWidth = 1
    for i in range(0, 401, cell):
        ctx.beginPath()
        ctx.moveTo(i, 0)
        ctx.lineTo(i, 400)
        ctx.stroke()
        ctx.beginPath()
        ctx.moveTo(0, i)
        ctx.lineTo(400, i)
        ctx.stroke()
    ctx.strokeStyle = "black"
    ctx.lineWidth = 2
    ctx.strokeRect(0, 0, 400, 400)

def draw_robot():
    draw_grid()
    cx = robot["x"] * cell + cell // 2
    cy = robot["y"] * cell + cell // 2
    size = 15
    d = robot["dir"]

    ctx.fillStyle = "blue"
    ctx.beginPath()
    if d == 0:  # 上
        ctx.moveTo(cx, cy - size)
        ctx.lineTo(cx - size, cy + size)
        ctx.lineTo(cx + size, cy + size)
    elif d == 1:  # 右
        ctx.moveTo(cx + size, cy)
        ctx.lineTo(cx - size, cy - size)
        ctx.lineTo(cx - size, cy + size)
    elif d == 2:  # 下
        ctx.moveTo(cx, cy + size)
        ctx.lineTo(cx - size, cy - size)
        ctx.lineTo(cx + size, cy - size)
    elif d == 3:  # 左
        ctx.moveTo(cx - size, cy)
        ctx.lineTo(cx + size, cy - size)
        ctx.lineTo(cx + size, cy + size)
    ctx.closePath()
    ctx.fill()

@bind(document, "keydown")
def on_key(e):
    key = e.key.lower()
    if key == "i":
        robot["dir"] = (robot["dir"] - 1) % 4  # 左轉
    elif key == "j":
        dx, dy = directions[robot["dir"]]
        nx = robot["x"] + dx
        ny = robot["y"] + dy
        if 0 &lt;= nx &lt; cols and 0 &lt;= ny &lt; rows:
            robot["x"] = nx
            robot["y"] = ny
    draw_robot()

draw_robot()</pre>
<p>Optimization:</p>
<p>題目:<br/>一位製造商想設計一個開口式的盒子，其底部為長方形，寬為 x、長為 y，且總表面積為 80 平方公分。 請問要使盒子的體積達到最大，應該選用哪些尺寸？</p>
<p>直接利用 Python 以 <a href="https://en.wikipedia.org/wiki/Differential_evolution">Differential Evoluation</a> 運算: <a href="/downloads/de_volume_max.py">de_volume_max.py</a></p>
<p style="padding-left: 30px;">參考: </p>
<p style="padding-left: 60px;"><a href="/downloads/de_volume_max.c">de_volume_max.c</a>, <a href="/downloads/de_volume_max.v">de_volume_max.v</a></p>
<p>也可以採網頁前端使用 Brython，後端採 Python 執行運算後將資料傳回網頁: <a href="/downloads/brython_w_flask.7z">brython_w_flask.7z</a></p>
<h1>Pyodide指令區</h1>
<p>
<script src="https://cdn.jsdelivr.net/pyodide/v0.26.4/full/pyodide.js"></script>
</p>
<p><button id="version">version</button> <button id="hello_button">hello</button> <button id="add1to100">1 add to 100</button> <button id="robot1">機器人巡邏</button><button id="free_walk">自由行</button> <button id="numpy_ode">numpy_ode</button></p>
<!-- Ace Editor Scripts -->
<p>
<script src="/static/ace/FileSaver.min.js"></script>
<script src="/static/ace/filereader.js"></script>
<script src="/static/ace/ace.js"></script>
<script src="/static/ace/ext-language_tools.js"></script>
<script src="/static/ace/mode-python.js"></script>
<script src="/static/ace/snippets/python.js"></script>
</p>
<!-- Editor 1 -->
<div id="kw_editor1" style="width: 600px; height: 300px;"></div>
<p><button id="kw_run1">Run</button> <button id="kw_output1">Output</button> <button id="kw_clear_console1">清除輸出區</button> <button onclick="location.reload()">Reload</button></p>
<p><textarea id="kw_console1"></textarea></p>
<div id="pyodide_div1"></div>
<div id="mpl_output1"></div>
<div id="brython_div1"></div>
<hr/>
<p>從 1 累加到 100 part2:</p>
<p><button id="add1to100part2">1 add to 100</button></p>
<!-- Editor 2 -->
<div id="kw_editor2" style="width: 600px; height: 300px;"></div>
<p><button id="kw_run2">Run</button> <button id="kw_output2">Output</button> <button id="kw_clear_console2">清除輸出區</button> <button onclick="location.reload()">Reload</button></p>
<p><textarea id="kw_console2"></textarea></p>
<div id="pyodide_div2"></div>
<div id="mpl_output2"></div>
<div id="brython_div2"></div>
<p>
<script>
function getUrlParam(key) {
  return new URLSearchParams(window.location.search).get(key);
}
function updateUrlParam(key, value) {
  const url = new URL(window.location);
  url.searchParams.set(key, value);
  window.history.replaceState({}, "", url);
}

let pyodide, editor1, editor2;

document.addEventListener("DOMContentLoaded", async () => {
  editor1 = ace.edit("kw_editor1");
  editor1.setTheme("ace/theme/chrome");
  editor1.session.setMode("ace/mode/python");

  editor2 = ace.edit("kw_editor2");
  editor2.setTheme("ace/theme/chrome");
  editor2.session.setMode("ace/mode/python");

  pyodide = await loadPyodide();
  await pyodide.loadPackage(["numpy", "scipy", "matplotlib", "micropip"]);

  // 定義 hello() 模組
  const code = `
def hello():
    print("Hello from custom module!")
`;
  pyodide.runPython(code);

  const GIST_ADD1TO100 =
    "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/" +
    "c48e37714f055c3a0027cbfef59e442a6ef659b9/from_1_add_to_100_1.py";
  const NUMPY_ODE =
    "https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/" +
    "98d582539545b3c9fbfa35dd3e605c506367618e/pyodide_ode_ex1.py";
  const PYODIDE_ROBOT_ANIMATION =
    "https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/" +
    "f3d75d08f2b90f4470342e91ee1e5c36b5f950bf/pyodide_robot_ex1.py";
  const FREE_WALK = 
    "https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/" + "d1659628afe5d36a026ef305dc639f6be4c9f608/pyodide_robot_ex3.py"

  const src = getUrlParam("src");
  if (src === PYODIDE_ROBOT_ANIMATION) {
    const robotCode = await fetchCode(PYODIDE_ROBOT_ANIMATION);
    editor1.setValue(robotCode, -1);
    updateUrlParam("src", PYODIDE_ROBOT_ANIMATION);
    runPyodide(editor1, "kw_console1", "brython_div1");
  } else {
    const initialCode = await fetchCode(src || GIST_ADD1TO100);
    editor1.setValue(initialCode, -1);
    runPyodide(editor1, "kw_console1", "brython_div1");
  }

  editor2.setValue("", -1);

  document.getElementById("version").onclick = () => {
    const vcode = `
import pyodide
import sys
import matplotlib
import numpy
import scipy
print("Pyodide version:", pyodide.__version__)
print("Python version :", sys.version)
print("matplotlib version:", matplotlib.__version__)
print("numpy version:", numpy.__version__)
print("scipy version:", scipy.__version__)
`;
    editor1.setValue(vcode, -1);
    updateUrlParam("src", "inline_version");
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("hello_button").onclick = () => {
    editor1.setValue("hello()", -1);
    updateUrlParam("src", "inline_hello");
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("add1to100").onclick = async () => {
    const c = await fetchCode(GIST_ADD1TO100);
    editor1.setValue(c, -1);
    updateUrlParam("src", GIST_ADD1TO100);
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("numpy_ode").onclick = async () => {
    const c = await fetchCode(NUMPY_ODE);
    editor1.setValue(c, -1);
    updateUrlParam("src", NUMPY_ODE);
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("robot1").onclick = async () => {
    const rc = await fetchCode(PYODIDE_ROBOT_ANIMATION);
    editor1.setValue(rc, -1);
    updateUrlParam("src", PYODIDE_ROBOT_ANIMATION);
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("free_walk").onclick = async () => {
    const rc = await fetchCode(FREE_WALK);
    editor1.setValue(rc, -1);
    updateUrlParam("src", FREE_WALK);
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("add1to100part2").onclick = async () => {
    const c = await fetchCode(GIST_ADD1TO100);
    editor2.setValue(c, -1);
    runPyodide(editor2, "kw_console2", "brython_div2");
  };

  document.getElementById("kw_run1").onclick = () =>
    runPyodide(editor1, "kw_console1", "brython_div1");
  document.getElementById("kw_run2").onclick = () =>
    runPyodide(editor2, "kw_console2", "brython_div2");
  document.getElementById("kw_clear_console1").onclick = () =>
    clearOutput("kw_console1", "brython_div1");
  document.getElementById("kw_clear_console2").onclick = () =>
    clearOutput("kw_console2", "brython_div2");
});

// 處理兩個 Output 列數
  document.getElementById("kw_output1").onclick = () => {
    const ta = document.getElementById("kw_console1");
    ta.rows = "15";
    ta.cols = "70";
    ta.scrollTop = 0;
  };
  document.getElementById("kw_output2").onclick = () => {
    const ta = document.getElementById("kw_console2");
    ta.rows = "15";
    ta.cols = "70";
    ta.scrollTop = 0;
  };

async function fetchCode(url) {
  const r = await fetch(url);
  if (!r.ok) throw new Error(`載入失敗 ${r.status}`);
  return await r.text();
}

function clearOutput(consoleId, divId) {
  document.getElementById(consoleId).value = "";
  document.getElementById(divId).innerHTML = "";
}

async function runPyodide(editor, consoleId, divId) {
  document.getElementById(consoleId).value = "";
  document.getElementById(divId).innerHTML = "";

  await pyodide.runPythonAsync(`
import sys
class JsWriter:
  def write(self, s):
    from js import document
    ta = document.getElementById("${consoleId}")
    ta.value += s
    ta.scrollTop = ta.scrollHeight
sys.stdout = JsWriter()
sys.stderr = JsWriter()
`);

  try {
    await pyodide.runPythonAsync(editor.getValue());
  } catch (e) {
    document.getElementById(consoleId).value += "\n錯誤：" + e.toString();
  }
}
</script>
</p>
<h2>Pyodide</h2>
<p><a href="https://mde.tw/cp2025/content/Pyodide.html?src=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/f3d75d08f2b90f4470342e91ee1e5c36b5f950bf/pyodide_robot_ex1.py">Pyodide 機器人巡邏</a></p>
<p>Pyodide 導入客製化模組:</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">const code = `
# 定義一個模組內容
def hello():
    print("Hello from custom module!")
`;
pyodide.runPython(code);
</pre>
<p><a href="https://mde.tw/cp2025/content/Pyodide.html?src=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/3ed6869dcd7312254513ca507de17945e15a9b6f/box_max_volume_short.py">Volume_max_pyodide_de_short.py</a></p>
<p><a href="https://mde.tw/cp2025/content/Pyodide.html?src=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/3ed6869dcd7312254513ca507de17945e15a9b6f/box_volume_max_pyodide_de.py">Volume_max_pyodide_de.py</a></p>
<p></p>
<h1>組長</h1>
<p></p>
<h1>w12</h1>
<h2>國旗旋轉</h2>
<p># 畫中華民國國旗，並展示 90 度與 45 度順時針旋轉<br/># 導入 doc<br/>from browser import document as doc<br/># 以下將利用 html 產生所需的繪圖畫布<br/>from browser import html<br/># 利用 math 函式庫執行三角函數運算<br/>import math</p>
<p># --- 畫布與環境設定 ---</p>
<p># 定義畫布尺寸<br/>FLAG_W = 600<br/>FLAG_H = 400<br/># 旋轉中心點<br/>CENTER_X = FLAG_W / 2<br/>CENTER_Y = FLAG_H / 2</p>
<p># 將畫布添加到 id 為 brython_div1 的 HTML 元素中<br/>brython_div = doc["brython_div1"]</p>
<p># 創建標籤和畫布<br/>brython_div &lt;= html.H3("原始國旗 (600x400)")<br/>canvas_orig = html.CANVAS(width = FLAG_W, height = FLAG_H, id = "flag_orig", style = {"border": "1px solid #ccc"})<br/>brython_div &lt;= canvas_orig</p>
<p>brython_div &lt;= html.H3("順時針旋轉 90 度")<br/>canvas_90 = html.CANVAS(width = FLAG_W, height = FLAG_H, id = "flag_90", style = {"border": "1px solid #ccc"})<br/>brython_div &lt;= canvas_90</p>
<p>brython_div &lt;= html.H3("順時針旋轉 45 度")<br/>canvas_45 = html.CANVAS(width = FLAG_W, height = FLAG_H, id = "flag_45", style = {"border": "1px solid #ccc"})<br/>brython_div &lt;= canvas_45</p>
<p># --- 核心繪圖函數 (國旗內容) ---<br/>def draw_flag_content(ctx):<br/> """繪製未旋轉狀態的國旗內容，所有座標都是基於 (0, 0) 起點"""<br/> flag_w = FLAG_W<br/> flag_h = FLAG_H<br/> <br/> # 青天白日圖案的中心座標 (位於左上四分之一處)<br/> circle_x = flag_w/4<br/> circle_y = flag_h/4<br/> star_radius = flag_w/8 # 白日光芒半徑</p>
<p># 1. 滿地紅 (Red Earth)<br/> ctx.fillStyle='rgb(255, 0, 0)'<br/> ctx.fillRect(0,0,flag_w,flag_h)</p>
<p># 2. 青天 (Blue Sky)<br/> ctx.fillStyle='rgb(0, 0, 150)'<br/> ctx.fillRect(0,0,flag_w/2,flag_h/2)</p>
<p># 3. 十二道光芒白日 (White Sun with Twelve Rays) - 採用原程式碼邏輯<br/> ctx.beginPath()<br/> angle = 0<br/> for i in range(24):<br/> # 採用原始程式碼中不常見的角度步進，確保旋轉前後形狀一致<br/> angle += 5*math.pi*2/12 <br/> toX = circle_x + math.cos(angle)*star_radius<br/> toY = circle_y + math.sin(angle)*star_radius<br/> if (i):<br/> ctx.lineTo(toX, toY)<br/> else:<br/> ctx.moveTo(toX, toY)<br/> ctx.closePath()<br/> ctx.fillStyle = '#fff'<br/> ctx.fill()</p>
<p># 4. 白日:藍圈 (Blue Ring)<br/> ctx.beginPath()<br/> # 原始半徑: flag_w * 17 / 240<br/> ctx.arc(circle_x, circle_y, flag_w*17/240, 0, math.pi*2, True)<br/> ctx.closePath()<br/> ctx.fillStyle = 'rgb(0, 0, 149)'<br/> ctx.fill()</p>
<p># 5. 白日:白心 (White Center)<br/> ctx.beginPath()<br/> # 原始半徑: flag_w / 16<br/> ctx.arc(circle_x, circle_y, flag_w/16, 0, math.pi*2, True)<br/> ctx.closePath()<br/> ctx.fillStyle = '#fff'<br/> ctx.fill()</p>
<p># --- 繪製函數：原始國旗 ---<br/>def draw_original_flag():<br/> ctx = doc["flag_orig"].getContext("2d")<br/> draw_flag_content(ctx)</p>
<p># --- 繪製函數：順時針旋轉 90 度 ---<br/>def draw_90_degree_flag():<br/> ctx = doc["flag_90"].getContext("2d")<br/> <br/> # 1. 儲存當前狀態<br/> ctx.save()<br/> <br/> # 2. 平移原點到畫布中心 (600/2, 400/2) = (300, 200)<br/> ctx.translate(CENTER_X, CENTER_Y)<br/> <br/> # 3. 旋轉 90 度 (π/2) 順時針<br/> ctx.rotate(math.pi / 2)<br/> <br/> # 4. 將原點平移回去，以便國旗內容以 (0, 0) 為起點繪製<br/> ctx.translate(-CENTER_X, -CENTER_Y)<br/> <br/> # 5. 繪製國旗內容<br/> draw_flag_content(ctx)<br/> <br/> # 6. 恢復狀態<br/> ctx.restore()</p>
<p># --- 繪製函數：順時針旋轉 45 度 ---<br/>def draw_45_degree_flag():<br/> ctx = doc["flag_45"].getContext("2d")<br/> <br/> # 1. 儲存當前狀態<br/> ctx.save()<br/> <br/> # 2. 平移原點到畫布中心<br/> ctx.translate(CENTER_X, CENTER_Y)<br/> <br/> # 3. 旋轉 45 度 (π/4) 順時針<br/> ctx.rotate(math.pi / 4)<br/> <br/> # 4. 將原點平移回去<br/> ctx.translate(-CENTER_X, -CENTER_Y)<br/> <br/> # 5. 繪製國旗內容<br/> draw_flag_content(ctx)<br/> <br/> # 6. 恢復狀態<br/> ctx.restore()</p>
<p># --- 執行繪圖 ---<br/>draw_original_flag()<br/>draw_90_degree_flag()<br/>draw_45_degree_flag()</p>
<h2>機器人七段程式碼</h2>
<p></p>
<p>#請修正以下程式讓機器人可以走出七段顯示器格式的數字<br/>from robot_lib import World as BaseWorld, AnimatedRobot as BaseRobot, timer, CELL_SIZE</p>
<p># --- 1. 定義世界（加入細格） ---<br/>class MyWorld(BaseWorld):<br/> def __init__(self, width=10, height=10, sub_cell=5):<br/> super().__init__(width, height)<br/> self.sub_cell = sub_cell<br/> self.sub_size = CELL_SIZE // sub_cell<br/> self._draw_fine_grid()</p>
<p>def _draw_fine_grid(self):<br/> ctx = self.layers["grid"].getContext("2d")<br/> ctx.strokeStyle = "#e0e0e0"<br/> ctx.lineWidth = 0.5<br/> # 畫垂直細線<br/> for i in range(self.width * self.sub_cell + 1):<br/> x = i * self.sub_size<br/> ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, self.height * CELL_SIZE); ctx.stroke()<br/> # 畫水平細線<br/> for j in range(self.height * self.sub_cell + 1):<br/> y = j * self.sub_size<br/> ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(self.width * CELL_SIZE, y); ctx.stroke()</p>
<p># 細格座標轉換為像素座標<br/> def sub_to_px(self, sub_x, sub_y):<br/> big_x = sub_x // self.sub_cell<br/> big_y = sub_y // self.sub_cell<br/> offset_x = (sub_x % self.sub_cell) * self.sub_size<br/> <br/> # 修正點 1: 反轉細格內 Y 偏移量 (oy)，使 sub_y 越大 (往下)，py 越大 (螢幕上往下)。<br/> # 這確保了我們將 (sub_x, sub_y) 視為 Y 軸向下增加的網格座標。<br/> sub_y_offset = sub_y % self.sub_cell<br/> offset_y = (self.sub_cell - 1 - sub_y_offset) * self.sub_size<br/> <br/> px = big_x * CELL_SIZE + offset_x + self.sub_size // 2<br/> <br/> # BaseWorld 的 Y 軸是從下往上。<br/> # 總像素 Y 座標 (py) 仍然需要反轉 big_y，以匹配螢幕座標（Y 軸向下）。<br/> py = (self.height - 1 - big_y) * CELL_SIZE + offset_y + self.sub_size // 2<br/> return px, py</p>
<p># 在細格座標上畫線<br/> def draw_line(self, x1, y1, x2, y2):<br/> ctx = self.layers["objects"].getContext("2d")<br/> ctx.strokeStyle = "#d33"<br/> ctx.lineWidth = 9<br/> ctx.lineCap = "round"<br/> ctx.beginPath()<br/> ctx.moveTo(*self.sub_to_px(x1, y1))<br/> ctx.lineTo(*self.sub_to_px(x2, y2))<br/> ctx.stroke()</p>
<p># --- 2. 定義機器人（以細格移動） ---<br/>class MyRobot(BaseRobot):<br/> def __init__(self, world, start_big_x=1, start_big_y=1):<br/> super().__init__(world, start_big_x, start_big_y)<br/> # 初始位置轉換為細格中心<br/> self.sub_x = start_big_x * world.sub_cell + world.sub_cell // 2<br/> self.sub_y = start_big_y * world.sub_cell + world.sub_cell // 2<br/> self.robot_size = world.sub_size * 1.8</p>
<p># 重新繪製機器人（使用細格座標）<br/> def _draw_robot(self):<br/> self.robot_ctx.clearRect(0, 0, self.world.width * CELL_SIZE, self.world.height * CELL_SIZE)<br/> img = self.images[self.facing]<br/> px, py = self.world.sub_to_px(self.sub_x, self.sub_y)<br/> s = self.robot_size<br/> if img.complete:<br/> self.robot_ctx.drawImage(img, px - s//2, py - s//2, s, s)</p>
<p># 瞬間移動（不畫線）<br/> def teleport_to(self, tx, ty):<br/> def action(done):<br/> self.sub_x, self.sub_y = tx, ty<br/> self._draw_robot()<br/> timer.set_timeout(done, 10)<br/> self.queue.append(action)<br/> self._run_queue()</p>
<p># 移動 + 畫線（最核心）<br/> def move_to(self, tx, ty, draw_trace=True):<br/> def action(done):<br/> def step():<br/> if self.sub_x == tx and self.sub_y == ty:<br/> done(); return<br/> prev_x, prev_y = self.sub_x, self.sub_y</p>
<p># 計算方向並轉向 (維持原始程式的邏輯，因其主要修正點不在這裡)<br/> dx = tx - self.sub_x<br/> dy = ty - self.sub_y<br/> if dx &gt; 0: target = "E"<br/> elif dx &lt; 0: target = "W"<br/> elif dy &gt; 0: target = "N"<br/> else: target = "S"</p>
<p># 同步轉向（安全版）<br/> while self.facing != target:<br/> idx = self.facing_order.index(self.facing)<br/> self.facing = self.facing_order[(idx + 1) % 4]</p>
<p># 移動一步<br/> self.sub_x += 1 if dx &gt; 0 else (-1 if dx &lt; 0 else 0)<br/> self.sub_y += 1 if dy &gt; 0 else (-1 if dy &lt; 0 else 0)</p>
<p>if draw_trace:<br/> self.world.draw_line(prev_x, prev_y, self.sub_x, self.sub_y)<br/> self._draw_robot()<br/> # 調整速度，讓線條更平滑<br/> timer.set_timeout(step, 40)<br/> step()<br/> self.queue.append(action)<br/> self._run_queue()</p>
<p># --- 3. 七段顯示器定義 ---<br/>SEGMENTS = {<br/> 0:[1,1,1,1,1,1,0], 1:[0,1,1,0,0,0,0], 2:[1,1,0,1,1,0,1],<br/> 3:[1,1,1,1,0,0,1], 4:[0,1,1,0,0,1,1], 5:[1,0,1,1,0,1,1],<br/> 6:[1,0,1,1,1,1,1], 7:[1,1,1,0,0,0,0], 8:[1,1,1,1,1,1,1],<br/> 9:[1,1,1,1,0,1,1]<br/>}</p>
<p># 每個線段的細格座標路徑（相對座標）<br/># 七段顯示器結構是相對座標，高度 7 細格 (0-6)，寬度 4 細格 (0-3)。<br/># 這裡定義的 PATHS 仍是 Y 軸向下增加 (Y=0 頂部, Y=6 底部)<br/>PATHS = [<br/> [(0,0),(1,0),(2,0),(3,0)], # A 上 (Y=0)<br/> [(3,0),(3,1),(3,2),(3,3)], # B 右上<br/> [(3,3),(3,4),(3,5),(3,6)], # C 右下<br/> [(3,6),(2,6),(1,6),(0,6)], # D 下 (Y=6)<br/> [(0,6),(0,5),(0,4),(0,3)], # E 左下<br/> [(0,3),(0,2),(0,1),(0,0)], # F 左上<br/> [(0,3),(1,3),(2,3),(3,3)] # G 中 (Y=3)<br/>]</p>
<p>def draw_digit(robot, digit, ox, oy):<br/> # 修正點 2: 引入七段顯示器的高度 (最大 Y 座標)<br/> SEGMENT_HEIGHT = 6<br/> if digit not in SEGMENTS: return<br/> <br/> for i, on in enumerate(SEGMENTS[digit]):<br/> if not on: continue<br/> path = PATHS[i]<br/> <br/> # 修正點 3: 進行 Y 座標反轉：y_fixed = oy + (SEGMENT_HEIGHT - relative_y)<br/> # 將 Y 軸向下增加的相對座標 (0-6) 轉換為 Y 軸向上增加的繪圖座標。<br/> <br/> # 初始位置<br/> start_x = ox + path[0][0]<br/> start_y = oy + (SEGMENT_HEIGHT - path[0][1]) # 關鍵反轉<br/> robot.teleport_to(start_x, start_y)<br/> <br/> for j in range(1, len(path)):<br/> tx = ox + path[j][0]<br/> ty = oy + (SEGMENT_HEIGHT - path[j][1]) # 關鍵反轉<br/> robot.move_to(tx, ty, draw_trace=True)</p>
<p># ==================== 主程式：畫 0123456789 ====================<br/># 修正 World 寬度，以容納 10 個數字 (10 * 6 寬度 + 邊距)<br/>world = MyWorld(65, 10, sub_cell=5) <br/># 將機器人起始點設在細格 (0, 0) 附近<br/>robot = MyRobot(world, 0, 0)</p>
<p># Y 軸偏移量 oy：<br/>START_Y_SUB_CELL = 1</p>
<p>for i in range(10):<br/> # 每個數字的起始 X 細格座標 (每個數字寬度 4，間隔 2，共 6 寬度)<br/> start_x_offset = 1 + i * 6 <br/> draw_digit(robot, i, start_x_offset, START_Y_SUB_CELL)</p>
<p>print("機器人正在寫字：0123456789 (已修正座標反轉問題)")</p>
<p></p>