var tipuesearch = {"pages": [{'title': '歡迎歡迎', 'text': '可攜程式套件: portable_2026.7z \xa0 \n 個人github: https://github.com/LanChienEn/w11 \n \n \n', 'tags': '', 'url': '歡迎歡迎.html'}, {'title': 'Brython指令區', 'text': '1 add to 100 機器人巡邏 自由行 \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  累加程式開始  \n \n  累加程式結束     機器人巡邏程式開始  \n \n  機器人巡邏程式結束  \n  機器人自由行程式開始  \n \n \n \n  機器人自由行程式結束  \n  add 1 to 100 開始  \n \n \n  add 1 to 100 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束   ##########################################  \n 從 1 累加到 100 part2: \n 1 add to 100 cango_three_gears BSnake AI Tetris \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  add 1 to 100 part2 開始  \n \n \n  add 1 to 100 part2 結束 \n  editor2 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor2 結束  \n \n', 'tags': '', 'url': 'Brython指令區.html'}, {'title': 'Brython', 'text': '機器人自由行 \n Can we bring pythonpad into this page?\xa0 https://pythonpad.github.io/docs/manual.html \xa0 \n from browser import document, html, timer\n \ncanvas = html.CANVAS(width=400, height=400)\nbrython_div = document["brython_div1"]\nbrython_div <= canvas\nctx = canvas.getContext("2d")\n \ndef draw_grid():\n    ctx.clearRect(0, 0, 400, 400)\n    ctx.strokeStyle = "#ccc"\n    ctx.lineWidth = 1\n    for i in range(0, 401, 40):\n        ctx.beginPath()\n        ctx.moveTo(i, 0)\n        ctx.lineTo(i, 400)\n        ctx.stroke()\n        ctx.beginPath()\n        ctx.moveTo(0, i)\n        ctx.lineTo(400, i)\n        ctx.stroke()\n    \n    # 畫出邊界\n    ctx.strokeStyle = "black"\n    ctx.lineWidth = 2\n    ctx.strokeRect(0, 0, 400, 400)\n\ndef draw_robot(x, y):\n    draw_grid()\n    ctx.fillStyle = "blue"\n    ctx.beginPath()\n    ctx.arc(x * 40 + 20, y * 40 + 20, 15, 0, 6.28)\n    ctx.fill()\n\nx, y = 0, 0\ndef move():\n    global x\n    x = (x + 1) % 10\n    draw_robot(x, y)\n\ndraw_grid()\ntimer.set_interval(move, 500) \n 以下程式, 按 j 隨箭頭方向前進, 按下 i 則左轉 \n from browser import document, html, bind\n\ncanvas = html.CANVAS(width=400, height=400)\nbrython_div = document["brython_div1"]\nbrython_div <= canvas\nctx = canvas.getContext("2d")\n\ncols, rows = 10, 10\ncell = 40\n\n# 上、右、下、左\ndirections = [(0, -1), (1, 0), (0, 1), (-1, 0)]\n\nrobot = {\n    "x": 5,\n    "y": 5,\n    "dir": 0  # 初始朝向上\n}\n\ndef draw_grid():\n    ctx.clearRect(0, 0, 400, 400)\n    ctx.strokeStyle = "#ccc"\n    ctx.lineWidth = 1\n    for i in range(0, 401, cell):\n        ctx.beginPath()\n        ctx.moveTo(i, 0)\n        ctx.lineTo(i, 400)\n        ctx.stroke()\n        ctx.beginPath()\n        ctx.moveTo(0, i)\n        ctx.lineTo(400, i)\n        ctx.stroke()\n    ctx.strokeStyle = "black"\n    ctx.lineWidth = 2\n    ctx.strokeRect(0, 0, 400, 400)\n\ndef draw_robot():\n    draw_grid()\n    cx = robot["x"] * cell + cell // 2\n    cy = robot["y"] * cell + cell // 2\n    size = 15\n    d = robot["dir"]\n\n    ctx.fillStyle = "blue"\n    ctx.beginPath()\n    if d == 0:  # 上\n        ctx.moveTo(cx, cy - size)\n        ctx.lineTo(cx - size, cy + size)\n        ctx.lineTo(cx + size, cy + size)\n    elif d == 1:  # 右\n        ctx.moveTo(cx + size, cy)\n        ctx.lineTo(cx - size, cy - size)\n        ctx.lineTo(cx - size, cy + size)\n    elif d == 2:  # 下\n        ctx.moveTo(cx, cy + size)\n        ctx.lineTo(cx - size, cy - size)\n        ctx.lineTo(cx + size, cy - size)\n    elif d == 3:  # 左\n        ctx.moveTo(cx - size, cy)\n        ctx.lineTo(cx + size, cy - size)\n        ctx.lineTo(cx + size, cy + size)\n    ctx.closePath()\n    ctx.fill()\n\n@bind(document, "keydown")\ndef on_key(e):\n    key = e.key.lower()\n    if key == "i":\n        robot["dir"] = (robot["dir"] - 1) % 4  # 左轉\n    elif key == "j":\n        dx, dy = directions[robot["dir"]]\n        nx = robot["x"] + dx\n        ny = robot["y"] + dy\n        if 0 <= nx < cols and 0 <= ny < rows:\n            robot["x"] = nx\n            robot["y"] = ny\n    draw_robot()\n\ndraw_robot() \n Optimization: \n 題目: 一位製造商想設計一個開口式的盒子，其底部為長方形，寬為 x、長為 y，且總表面積為 80 平方公分。 請問要使盒子的體積達到最大，應該選用哪些尺寸？ \n 直接利用 Python 以  Differential Evoluation  運算:\xa0 de_volume_max.py \n 參考:\xa0 \n de_volume_max.c ,\xa0 de_volume_max.v \n 也可以採網頁前端使用 Brython，後端採 Python 執行運算後將資料傳回網頁:\xa0 brython_w_flask.7z \n', 'tags': '', 'url': 'Brython.html'}, {'title': 'Pyodide指令區', 'text': '\n \n \n version   hello   1 add to 100   機器人巡邏 自由行   numpy_ode \n  Ace Editor Scripts  \n \n \n \n \n \n \n \n \n  Editor 1  \n \n Run   Output   清除輸出區   Reload \n \n \n \n \n \n 從 1 累加到 100 part2: \n 1 add to 100 \n  Editor 2  \n \n Run   Output   清除輸出區   Reload \n \n \n \n \n \n \n \n', 'tags': '', 'url': 'Pyodide指令區.html'}, {'title': 'Pyodide', 'text': 'Pyodide 機器人巡邏 \n Pyodide 導入客製化模組: \n const code = `\n# 定義一個模組內容\ndef hello():\n    print("Hello from custom module!")\n`;\npyodide.runPython(code);\n \n Volume_max_pyodide_de_short.py \n Volume_max_pyodide_de.py \n \n', 'tags': '', 'url': 'Pyodide.html'}, {'title': '組長', 'text': '\n', 'tags': '', 'url': '組長.html'}, {'title': 'w12', 'text': '', 'tags': '', 'url': 'w12.html'}, {'title': '國旗旋轉', 'text': '# 畫中華民國國旗，並展示 90 度與 45 度順時針旋轉 # 導入 doc from browser import document as doc # 以下將利用 html 產生所需的繪圖畫布 from browser import html # 利用 math 函式庫執行三角函數運算 import math \n # --- 畫布與環境設定 --- \n # 定義畫布尺寸 FLAG_W = 600 FLAG_H = 400 # 旋轉中心點 CENTER_X = FLAG_W / 2 CENTER_Y = FLAG_H / 2 \n # 將畫布添加到 id 為 brython_div1 的 HTML 元素中 brython_div = doc["brython_div1"] \n # 創建標籤和畫布 brython_div <= html.H3("原始國旗 (600x400)") canvas_orig = html.CANVAS(width = FLAG_W, height = FLAG_H, id = "flag_orig", style = {"border": "1px solid #ccc"}) brython_div <= canvas_orig \n brython_div <= html.H3("順時針旋轉 90 度") canvas_90 = html.CANVAS(width = FLAG_W, height = FLAG_H, id = "flag_90", style = {"border": "1px solid #ccc"}) brython_div <= canvas_90 \n brython_div <= html.H3("順時針旋轉 45 度") canvas_45 = html.CANVAS(width = FLAG_W, height = FLAG_H, id = "flag_45", style = {"border": "1px solid #ccc"}) brython_div <= canvas_45 \n # --- 核心繪圖函數 (國旗內容) --- def draw_flag_content(ctx):  """繪製未旋轉狀態的國旗內容，所有座標都是基於 (0, 0) 起點"""  flag_w = FLAG_W  flag_h = FLAG_H    # 青天白日圖案的中心座標 (位於左上四分之一處)  circle_x = flag_w/4  circle_y = flag_h/4  star_radius = flag_w/8 # 白日光芒半徑 \n # 1. 滿地紅 (Red Earth)  ctx.fillStyle=\'rgb(255, 0, 0)\'  ctx.fillRect(0,0,flag_w,flag_h) \n # 2. 青天 (Blue Sky)  ctx.fillStyle=\'rgb(0, 0, 150)\'  ctx.fillRect(0,0,flag_w/2,flag_h/2) \n # 3. 十二道光芒白日 (White Sun with Twelve Rays) - 採用原程式碼邏輯  ctx.beginPath()  angle = 0  for i in range(24):  # 採用原始程式碼中不常見的角度步進，確保旋轉前後形狀一致  angle += 5*math.pi*2/12   toX = circle_x + math.cos(angle)*star_radius  toY = circle_y + math.sin(angle)*star_radius  if (i):  ctx.lineTo(toX, toY)  else:  ctx.moveTo(toX, toY)  ctx.closePath()  ctx.fillStyle = \'#fff\'  ctx.fill() \n # 4. 白日:藍圈 (Blue Ring)  ctx.beginPath()  # 原始半徑: flag_w * 17 / 240  ctx.arc(circle_x, circle_y, flag_w*17/240, 0, math.pi*2, True)  ctx.closePath()  ctx.fillStyle = \'rgb(0, 0, 149)\'  ctx.fill() \n # 5. 白日:白心 (White Center)  ctx.beginPath()  # 原始半徑: flag_w / 16  ctx.arc(circle_x, circle_y, flag_w/16, 0, math.pi*2, True)  ctx.closePath()  ctx.fillStyle = \'#fff\'  ctx.fill() \n # --- 繪製函數：原始國旗 --- def draw_original_flag():  ctx = doc["flag_orig"].getContext("2d")  draw_flag_content(ctx) \n # --- 繪製函數：順時針旋轉 90 度 --- def draw_90_degree_flag():  ctx = doc["flag_90"].getContext("2d")    # 1. 儲存當前狀態  ctx.save()    # 2. 平移原點到畫布中心 (600/2, 400/2) = (300, 200)  ctx.translate(CENTER_X, CENTER_Y)    # 3. 旋轉 90 度 (π/2) 順時針  ctx.rotate(math.pi / 2)    # 4. 將原點平移回去，以便國旗內容以 (0, 0) 為起點繪製  ctx.translate(-CENTER_X, -CENTER_Y)    # 5. 繪製國旗內容  draw_flag_content(ctx)    # 6. 恢復狀態  ctx.restore() \n # --- 繪製函數：順時針旋轉 45 度 --- def draw_45_degree_flag():  ctx = doc["flag_45"].getContext("2d")    # 1. 儲存當前狀態  ctx.save()    # 2. 平移原點到畫布中心  ctx.translate(CENTER_X, CENTER_Y)    # 3. 旋轉 45 度 (π/4) 順時針  ctx.rotate(math.pi / 4)    # 4. 將原點平移回去  ctx.translate(-CENTER_X, -CENTER_Y)    # 5. 繪製國旗內容  draw_flag_content(ctx)    # 6. 恢復狀態  ctx.restore() \n # --- 執行繪圖 --- draw_original_flag() draw_90_degree_flag() draw_45_degree_flag() \n', 'tags': '', 'url': '國旗旋轉.html'}, {'title': '機器人七段程式碼', 'text': '\n #請修正以下程式讓機器人可以走出七段顯示器格式的數字 from robot_lib import World as BaseWorld, AnimatedRobot as BaseRobot, timer, CELL_SIZE \n # --- 1. 定義世界（加入細格） --- class MyWorld(BaseWorld):  def __init__(self, width=10, height=10, sub_cell=5):  super().__init__(width, height)  self.sub_cell = sub_cell  self.sub_size = CELL_SIZE // sub_cell  self._draw_fine_grid() \n def _draw_fine_grid(self):  ctx = self.layers["grid"].getContext("2d")  ctx.strokeStyle = "#e0e0e0"  ctx.lineWidth = 0.5  # 畫垂直細線  for i in range(self.width * self.sub_cell + 1):  x = i * self.sub_size  ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, self.height * CELL_SIZE); ctx.stroke()  # 畫水平細線  for j in range(self.height * self.sub_cell + 1):  y = j * self.sub_size  ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(self.width * CELL_SIZE, y); ctx.stroke() \n # 細格座標轉換為像素座標  def sub_to_px(self, sub_x, sub_y):  big_x = sub_x // self.sub_cell  big_y = sub_y // self.sub_cell  offset_x = (sub_x % self.sub_cell) * self.sub_size    # 修正點 1: 反轉細格內 Y 偏移量 (oy)，使 sub_y 越大 (往下)，py 越大 (螢幕上往下)。  # 這確保了我們將 (sub_x, sub_y) 視為 Y 軸向下增加的網格座標。  sub_y_offset = sub_y % self.sub_cell  offset_y = (self.sub_cell - 1 - sub_y_offset) * self.sub_size    px = big_x * CELL_SIZE + offset_x + self.sub_size // 2    # BaseWorld 的 Y 軸是從下往上。  # 總像素 Y 座標 (py) 仍然需要反轉 big_y，以匹配螢幕座標（Y 軸向下）。  py = (self.height - 1 - big_y) * CELL_SIZE + offset_y + self.sub_size // 2  return px, py \n # 在細格座標上畫線  def draw_line(self, x1, y1, x2, y2):  ctx = self.layers["objects"].getContext("2d")  ctx.strokeStyle = "#d33"  ctx.lineWidth = 9  ctx.lineCap = "round"  ctx.beginPath()  ctx.moveTo(*self.sub_to_px(x1, y1))  ctx.lineTo(*self.sub_to_px(x2, y2))  ctx.stroke() \n # --- 2. 定義機器人（以細格移動） --- class MyRobot(BaseRobot):  def __init__(self, world, start_big_x=1, start_big_y=1):  super().__init__(world, start_big_x, start_big_y)  # 初始位置轉換為細格中心  self.sub_x = start_big_x * world.sub_cell + world.sub_cell // 2  self.sub_y = start_big_y * world.sub_cell + world.sub_cell // 2  self.robot_size = world.sub_size * 1.8 \n # 重新繪製機器人（使用細格座標）  def _draw_robot(self):  self.robot_ctx.clearRect(0, 0, self.world.width * CELL_SIZE, self.world.height * CELL_SIZE)  img = self.images[self.facing]  px, py = self.world.sub_to_px(self.sub_x, self.sub_y)  s = self.robot_size  if img.complete:  self.robot_ctx.drawImage(img, px - s//2, py - s//2, s, s) \n # 瞬間移動（不畫線）  def teleport_to(self, tx, ty):  def action(done):  self.sub_x, self.sub_y = tx, ty  self._draw_robot()  timer.set_timeout(done, 10)  self.queue.append(action)  self._run_queue() \n # 移動 + 畫線（最核心）  def move_to(self, tx, ty, draw_trace=True):  def action(done):  def step():  if self.sub_x == tx and self.sub_y == ty:  done(); return  prev_x, prev_y = self.sub_x, self.sub_y \n # 計算方向並轉向 (維持原始程式的邏輯，因其主要修正點不在這裡)  dx = tx - self.sub_x  dy = ty - self.sub_y  if dx > 0: target = "E"  elif dx < 0: target = "W"  elif dy > 0: target = "N"  else: target = "S" \n # 同步轉向（安全版）  while self.facing != target:  idx = self.facing_order.index(self.facing)  self.facing = self.facing_order[(idx + 1) % 4] \n # 移動一步  self.sub_x += 1 if dx > 0 else (-1 if dx < 0 else 0)  self.sub_y += 1 if dy > 0 else (-1 if dy < 0 else 0) \n if draw_trace:  self.world.draw_line(prev_x, prev_y, self.sub_x, self.sub_y)  self._draw_robot()  # 調整速度，讓線條更平滑  timer.set_timeout(step, 40)  step()  self.queue.append(action)  self._run_queue() \n # --- 3. 七段顯示器定義 --- SEGMENTS = {  0:[1,1,1,1,1,1,0], 1:[0,1,1,0,0,0,0], 2:[1,1,0,1,1,0,1],  3:[1,1,1,1,0,0,1], 4:[0,1,1,0,0,1,1], 5:[1,0,1,1,0,1,1],  6:[1,0,1,1,1,1,1], 7:[1,1,1,0,0,0,0], 8:[1,1,1,1,1,1,1],  9:[1,1,1,1,0,1,1] } \n # 每個線段的細格座標路徑（相對座標） # 七段顯示器結構是相對座標，高度 7 細格 (0-6)，寬度 4 細格 (0-3)。 # 這裡定義的 PATHS 仍是 Y 軸向下增加 (Y=0 頂部, Y=6 底部) PATHS = [  [(0,0),(1,0),(2,0),(3,0)], # A 上 (Y=0)  [(3,0),(3,1),(3,2),(3,3)], # B 右上  [(3,3),(3,4),(3,5),(3,6)], # C 右下  [(3,6),(2,6),(1,6),(0,6)], # D 下 (Y=6)  [(0,6),(0,5),(0,4),(0,3)], # E 左下  [(0,3),(0,2),(0,1),(0,0)], # F 左上  [(0,3),(1,3),(2,3),(3,3)] # G 中 (Y=3) ] \n def draw_digit(robot, digit, ox, oy):  # 修正點 2: 引入七段顯示器的高度 (最大 Y 座標)  SEGMENT_HEIGHT = 6  if digit not in SEGMENTS: return    for i, on in enumerate(SEGMENTS[digit]):  if not on: continue  path = PATHS[i]    # 修正點 3: 進行 Y 座標反轉：y_fixed = oy + (SEGMENT_HEIGHT - relative_y)  # 將 Y 軸向下增加的相對座標 (0-6) 轉換為 Y 軸向上增加的繪圖座標。    # 初始位置  start_x = ox + path[0][0]  start_y = oy + (SEGMENT_HEIGHT - path[0][1]) # 關鍵反轉  robot.teleport_to(start_x, start_y)    for j in range(1, len(path)):  tx = ox + path[j][0]  ty = oy + (SEGMENT_HEIGHT - path[j][1]) # 關鍵反轉  robot.move_to(tx, ty, draw_trace=True) \n # ==================== 主程式：畫 0123456789 ==================== # 修正 World 寬度，以容納 10 個數字 (10 * 6 寬度 + 邊距) world = MyWorld(65, 10, sub_cell=5)  # 將機器人起始點設在細格 (0, 0) 附近 robot = MyRobot(world, 0, 0) \n # Y 軸偏移量 oy： START_Y_SUB_CELL = 1 \n for i in range(10):  # 每個數字的起始 X 細格座標 (每個數字寬度 4，間隔 2，共 6 寬度)  start_x_offset = 1 + i * 6   draw_digit(robot, i, start_x_offset, START_Y_SUB_CELL) \n print("機器人正在寫字：0123456789 (已修正座標反轉問題)") \n', 'tags': '', 'url': '機器人七段程式碼.html'}]};