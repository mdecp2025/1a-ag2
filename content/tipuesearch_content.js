var tipuesearch = {"pages": [{'title': '首頁', 'text': 'Login 密碼:admin \n 可攜程式: portable_2026.7z \xa0 \n 組長:籃健恩\xa0\xa0 https://github.com/LanChienEn/w11 \n 組員:黃育驊\xa0 https://qwe43157.github.io/41136123/ \n \n \n', 'tags': '', 'url': '首頁.html'}, {'title': 'Brython指令區', 'text': '1 add to 100 機器人巡邏 自由行 \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  累加程式開始  \n \n  累加程式結束     機器人巡邏程式開始  \n \n  機器人巡邏程式結束  \n  機器人自由行程式開始  \n \n \n \n  機器人自由行程式結束  \n  add 1 to 100 開始  \n \n \n  add 1 to 100 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束   ##########################################  \n 從 1 累加到 100 part2: \n 1 add to 100 cango_three_gears BSnake AI Tetris \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  add 1 to 100 part2 開始  \n \n \n  add 1 to 100 part2 結束 \n  editor2 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor2 結束  \n \n', 'tags': '', 'url': 'Brython指令區.html'}, {'title': 'Brython', 'text': '機器人自由行 \n Can we bring pythonpad into this page?\xa0 https://pythonpad.github.io/docs/manual.html \xa0 \n from browser import document, html, timer\n \ncanvas = html.CANVAS(width=400, height=400)\nbrython_div = document["brython_div1"]\nbrython_div <= canvas\nctx = canvas.getContext("2d")\n \ndef draw_grid():\n    ctx.clearRect(0, 0, 400, 400)\n    ctx.strokeStyle = "#ccc"\n    ctx.lineWidth = 1\n    for i in range(0, 401, 40):\n        ctx.beginPath()\n        ctx.moveTo(i, 0)\n        ctx.lineTo(i, 400)\n        ctx.stroke()\n        ctx.beginPath()\n        ctx.moveTo(0, i)\n        ctx.lineTo(400, i)\n        ctx.stroke()\n    \n    # 畫出邊界\n    ctx.strokeStyle = "black"\n    ctx.lineWidth = 2\n    ctx.strokeRect(0, 0, 400, 400)\n\ndef draw_robot(x, y):\n    draw_grid()\n    ctx.fillStyle = "blue"\n    ctx.beginPath()\n    ctx.arc(x * 40 + 20, y * 40 + 20, 15, 0, 6.28)\n    ctx.fill()\n\nx, y = 0, 0\ndef move():\n    global x\n    x = (x + 1) % 10\n    draw_robot(x, y)\n\ndraw_grid()\ntimer.set_interval(move, 500) \n 以下程式, 按 j 隨箭頭方向前進, 按下 i 則左轉 \n from browser import document, html, bind\n\ncanvas = html.CANVAS(width=400, height=400)\nbrython_div = document["brython_div1"]\nbrython_div <= canvas\nctx = canvas.getContext("2d")\n\ncols, rows = 10, 10\ncell = 40\n\n# 上、右、下、左\ndirections = [(0, -1), (1, 0), (0, 1), (-1, 0)]\n\nrobot = {\n    "x": 5,\n    "y": 5,\n    "dir": 0  # 初始朝向上\n}\n\ndef draw_grid():\n    ctx.clearRect(0, 0, 400, 400)\n    ctx.strokeStyle = "#ccc"\n    ctx.lineWidth = 1\n    for i in range(0, 401, cell):\n        ctx.beginPath()\n        ctx.moveTo(i, 0)\n        ctx.lineTo(i, 400)\n        ctx.stroke()\n        ctx.beginPath()\n        ctx.moveTo(0, i)\n        ctx.lineTo(400, i)\n        ctx.stroke()\n    ctx.strokeStyle = "black"\n    ctx.lineWidth = 2\n    ctx.strokeRect(0, 0, 400, 400)\n\ndef draw_robot():\n    draw_grid()\n    cx = robot["x"] * cell + cell // 2\n    cy = robot["y"] * cell + cell // 2\n    size = 15\n    d = robot["dir"]\n\n    ctx.fillStyle = "blue"\n    ctx.beginPath()\n    if d == 0:  # 上\n        ctx.moveTo(cx, cy - size)\n        ctx.lineTo(cx - size, cy + size)\n        ctx.lineTo(cx + size, cy + size)\n    elif d == 1:  # 右\n        ctx.moveTo(cx + size, cy)\n        ctx.lineTo(cx - size, cy - size)\n        ctx.lineTo(cx - size, cy + size)\n    elif d == 2:  # 下\n        ctx.moveTo(cx, cy + size)\n        ctx.lineTo(cx - size, cy - size)\n        ctx.lineTo(cx + size, cy - size)\n    elif d == 3:  # 左\n        ctx.moveTo(cx - size, cy)\n        ctx.lineTo(cx + size, cy - size)\n        ctx.lineTo(cx + size, cy + size)\n    ctx.closePath()\n    ctx.fill()\n\n@bind(document, "keydown")\ndef on_key(e):\n    key = e.key.lower()\n    if key == "i":\n        robot["dir"] = (robot["dir"] - 1) % 4  # 左轉\n    elif key == "j":\n        dx, dy = directions[robot["dir"]]\n        nx = robot["x"] + dx\n        ny = robot["y"] + dy\n        if 0 <= nx < cols and 0 <= ny < rows:\n            robot["x"] = nx\n            robot["y"] = ny\n    draw_robot()\n\ndraw_robot() \n Optimization: \n 題目: 一位製造商想設計一個開口式的盒子，其底部為長方形，寬為 x、長為 y，且總表面積為 80 平方公分。 請問要使盒子的體積達到最大，應該選用哪些尺寸？ \n 直接利用 Python 以  Differential Evoluation  運算:\xa0 de_volume_max.py \n 參考:\xa0 \n de_volume_max.c ,\xa0 de_volume_max.v \n 也可以採網頁前端使用 Brython，後端採 Python 執行運算後將資料傳回網頁:\xa0 brython_w_flask.7z \n', 'tags': '', 'url': 'Brython.html'}, {'title': 'Pyodide指令區', 'text': '\n \n \n version   hello   1 add to 100   機器人巡邏 自由行   numpy_ode \n  Ace Editor Scripts  \n \n \n \n \n \n \n \n \n  Editor 1  \n \n Run   Output   清除輸出區   Reload \n \n \n \n \n \n 從 1 累加到 100 part2: \n 1 add to 100 \n  Editor 2  \n \n Run   Output   清除輸出區   Reload \n \n \n \n \n \n \n \n', 'tags': '', 'url': 'Pyodide指令區.html'}, {'title': 'Pyodide', 'text': 'Pyodide 機器人巡邏 \n Pyodide 導入客製化模組: \n const code = `\n# 定義一個模組內容\ndef hello():\n    print("Hello from custom module!")\n`;\npyodide.runPython(code);\n \n Volume_max_pyodide_de_short.py \n Volume_max_pyodide_de.py \n', 'tags': '', 'url': 'Pyodide.html'}, {'title': '學習心得報告主題', 'text': '', 'tags': '', 'url': '學習心得報告主題.html'}, {'title': 'w3', 'text': '什麼是 git, GitHub, gist 與 cmsimde? 如何使用這些工具？為什麼要使用這些工具？ \n 為何Git 與 Github? \n 使用 Git 與 GitHub 主要有以下幾個原因： \n \n 版本控制: Git 是一套分散式的版本控制系統，能記錄每一個檔案的修改歷程。這樣就算不小心改壞了某一個版本的程式，也能隨時回復到以前的版本，而且在協同設計流程中，可以追蹤那一個使用者改了那些內容、什麼時候改的，可以快速釐清許多議題。 \n 團隊協作:\xa0多個開發者可以同時對同一個專案進行開發，透過分支（branch）機制，各自開發新功能、修 bug，最後再合併（merge）到主分支，避免互相覆蓋程式碼。 \n 雲端備份與分享:\xa0GitHub 是基於 Git 的雲端代管平台，可以將本地的 Git 專案上傳到雲端，不怕資料遺失。也方便將程式碼公開或私下分享給其他人。 \n 問題追蹤與管理:\xa0GitHub 除了儲存程式碼，還提供 issue、pull request 等工具，有助於追蹤 bug、討論功能、審查程式碼，提高專案管理效率。 \n 開放原始碼與社群合作:\xa0許多開放原始碼專案都放在 GitHub，任何人都能貢獻程式碼，促進社群協作與學習。 \n 總結：使用 Git 和 GitHub 可以讓程式開發更有組織、更安全、更容易協作與管理，也方便與他人分享、學習與成長。 \n \n 請舉實際的計算機程式開發案例，說明如何操作 Git 與 Github，以便取得程式開發流程的便利與優勢。 \n Git 與 GitHub 操作案例說明 \n Git 與 GitHub 實際操作案例：多人開發 ToDo List 網站 \n \n 1. 專案初始化與上傳 \n \n 步驟: \n \n 在本機建立專案資料夾，初始化 Git：\n git init \n \n 新增檔案（如 \xa0 index.html 、 app.js ），並提交第一個版本：\n git add . git commit -m "Initial commit" \n \n 在 GitHub 建立新 repository，然後將本機專案推送到遠端：\n git remote add origin https://github.com/username/todo-app.git git push -u origin master \n \n \n 優勢: 所有程式碼都有歷史紀錄，且安全備份於雲端。 \n \n \n \n 2. 分支開發新功能 \n \n 情境: 小明負責開發「新增待辦事項」功能。 \n 步驟: \n \n 建立新分支：\n git checkout -b feature/add-todo-item \n \n 實作功能並提交：\n git add . git commit -m "Add feature to create todo item" \n \n 推送分支到 GitHub：\n git push origin feature/add-todo-item \n \n \n 優勢: 各自分支開發，互不干擾，降低衝突風險。 \n \n \n \n 3. Pull Request（合併請求）與 Code Review \n \n 情境: 小明開發完成，欲合併新功能到主分支。 \n 步驟: \n \n 在 GitHub 上建立 Pull Request，描述功能內容。 \n 其他團隊成員審查程式碼，提出建議或修正。 \n 經討論無誤後，管理員合併 PR。 \n \n 優勢: 強化程式品質與團隊溝通，每次合併都有討論紀錄。 \n \n \n \n 4. 處理 Bug 與 Issue 追蹤 \n \n 情境: 使用者發現「無法刪除待辦事項」的 bug。 \n 步驟: \n \n 在 GitHub issue 區提出 bug 報告。 \n 團隊分配成員修正，建立 \xa0 fix/delete-todo-bug \xa0 分支。 \n 修正後提交、發 PR、review、合併。 \n \n 優勢: 所有 bug、功能需求有明確記錄，修正過程透明。 \n \n \n \n 5. 版本回溯與復原 \n \n 情境: 新功能導致主分支出錯。 \n 步驟: \n \n 透過 Git log 查找歷史版本：\n git log \n \n 回復到上一個穩定版本：\n git checkout <commit-id> \n \n \n 優勢: 不怕程式「改壞」，可隨時回復，輕鬆追蹤誰做了什麼修改。 \n \n \n \n 總結: \n Git 與 GitHub 提供完整的版本控制、團隊協作、問題追蹤、程式碼審查與備份機制，讓開發流程更有條理，大幅提升開發效率與品質。不論團隊或個人開發，都能享有回溯、備份、管理等多重好處。 \n \n', 'tags': '', 'url': 'w3.html'}, {'title': 'w7', 'text': 'Brython 是什麼？如何在瀏覽器配置 Brython 環境？ Brython 能做什麼？ \n A1. Brython \xa0是一個將\xa0 Python \xa0語法編譯為\xa0 JavaScript \xa0的工具，能直接在瀏覽器中以\xa0 Python \xa0撰寫前端網頁程式。 \n A2. \n A3. \n', 'tags': '', 'url': 'w7.html'}, {'title': 'w10', 'text': '如何在瀏覽器中模擬機器人作動？ \n \n', 'tags': '', 'url': 'w10.html'}, {'title': 'w14', 'text': '在瀏覽器中模擬機器人作動的目的是什麼？ \n \n', 'tags': '', 'url': 'w14.html'}, {'title': 'w11', 'text': '', 'tags': '', 'url': 'w11.html'}, {'title': '如何建立團體github網站', 'text': '', 'tags': '', 'url': '如何建立團體github網站.html'}, {'title': '一般作法', 'text': '首先在github下載以教授給的cp demo做範本。進入Codespaces裡輸入程式、載入phython套件，然後在網路上開終端機進入編輯範例網站畫面。 \n', 'tags': '', 'url': '一般作法.html'}, {'title': '我的作法', 'text': '1.最初: 鏡射 自己的 個人倉儲網站 的個人網站。 \n 2.一開始先 同步 自己的個人倉儲 到團體 \n 以下是詢問AI的過程: \n 我: \n 我現在有一個個人github倉儲，我該怎麼樣把我這一個倉儲完全複製(包括修改歷程)到另一個分組倉儲? \n AI: \n 要完整複製一個 GitHub 倉儲（包含所有 commit / branch / tag 的歷史）到另一個分組倉儲，最正確、乾淨、不會漏歷史的方法是用 mirror（鏡像）推送。 \n 下面我分成「✅推薦做法」與「⚠️常見錯誤」來說。 \n ✅ 推薦做法：git clone --mirror（完整保留歷史） 🎯 適用情境 \n 你有 個人 repo想把它 100% 原封不動複製到 分組 repo \n 包含：所有 commit \n 所有 branch \n 所有 tag \n 所有歷史 \n Step 1️⃣ 複製「個人倉儲」為鏡像 git clone --mirror https://github.com/你的帳號/個人倉儲.git \n 這會產生一個資料夾，例如： \n 個人倉儲.git/ \n ⚠️ 注意：這不是一般的 clone，不要進去改檔案 \n Step 2️⃣ 進入鏡像倉儲資料夾 cd 個人倉儲.git \n Step 3️⃣ 設定新的 remote（分組倉儲） git remote set-url --push origin https://github.com/分組帳號/分組倉儲.git \n （你可以用 git remote -v 確認） \n Step 4️⃣ 推送「所有歷史」到分組倉儲 git push --mirror \n 🎉 完成！ \n 分組倉儲現在會有： \n 完整 commit 紀錄 \n 所有分支 \n 所有 tag → 跟你個人倉儲一模一樣 \n 🧪 確認是否成功（可選） \n 到 GitHub 分組倉儲頁面確認： \n Commit 歷史有沒有完整 \n 分支是否齊全 \n ⚠️ 常見錯誤（不推薦） ❌ 只做這樣： git remote add origin ... git push \n 👉 只會推目前 branch 👉 歷史可能不完整 👉 tag / 其他 branch 會消失 \n 🧠 如果你「之後要繼續在分組 repo 開發」 做完 mirror 後，重新正常 clone 一次分組 repo： git clone https://github.com/分組帳號/分組倉儲.git \n 然後之後都用這個 repo 開發即可。 \n 🆘 特殊情況提醒 情況 解法 分組 repo 已經有內容 需要先刪 repo 或確定你要覆蓋 沒有 push 權限 要請組長把你加成 collaborator \n 我: \n 我有在自己個人倉儲上傳新的內容，但沒有跟團體倉儲同步上傳新的內容。我該怎麼一起同步到團體倉儲裡?讓我個人的倉儲更新的內容可以跟團體倉儲同步。 \n AI: \n 這個問題問得非常好，而且很常見 👍 現在你的狀況是「兩個倉儲已經分家」，我幫你用最安全、不會被老師誤會的方式處理。 \n 🎯 你現在的狀態（重點釐清） \n ✅ 個人倉儲：有「新的 commit」 \n ✅ Classroom 團體倉儲：還停在舊狀態 \n ❌ 目前 兩邊沒有自動同步 \n 👉 Git 不會自動同步兩個 repo 👉 你必須「選一個作為主來源」 \n ✅ 最推薦、最安全的做法（助教／老師也認可） ⭐ 原則（請一定照這個） \n 之後「只用團體倉儲開發」 個人倉儲只當「舊來源」，把更新補進來一次即可 \n 🟢 做法 A（推薦）：把「個人倉儲的更新」合併到團體倉儲 🎯 適合你現在的情況 \n 個人倉儲有新 commit \n 團體倉儲是交作業用（最終版） \n 🧭 實際操作（一步一步） ① 進入 團體倉儲資料夾 cd Y:\\1a-ag2 \n ② 加入「個人倉儲」作為另一個 remote git remote add personal https://github.com/LanChienEn/w11.git \n 確認一下： \n git remote -v \n 你會看到： \n origin → Classroom \n personal → 個人倉儲 \n ③ 抓取個人倉儲的更新（不會改你本地檔案） git fetch personal \n ④ 把個人倉儲的 main（或 master）合併進來 \n ⚠️ 請選你實際使用的分支（通常是 main） \n git merge personal/main \n 如果你是 master： \n git merge personal/master \n ⑤ 推送到 Classroom 團體倉儲 git push \n 🎉 完成同步 \n 🧠 合併後會發生什麼？ \n ✅ 個人倉儲的新 commit 完整保留 \n ✅ commit 作者、時間都正確 \n ✅ Classroom repo 出現「正常 merge 紀錄」 \n ✅ 老師看到的是「合理開發流程」 \n ⚠️ 如果出現衝突（conflict） \n Git 會提示哪些檔案衝突： \n git status \n 你只要： \n 打開衝突檔案 \n 保留你要的版本 \n 存檔後： \n git add . git commit git push \n （如果你要，我可以教你「怎麼看衝突標記」） \n 🚫 不推薦的做法（但說給你知道） ❌ 再次用 git push --mirror \n 會 覆蓋 Classroom \n 可能影響同組同學 \n 老師會覺得歷史怪怪的 \n 👉 現在不要再用 mirror \n 🟡 什麼時候才可以再 mirror？ \n 只有一個人 \n 團體 repo 完全沒人動 \n 老師允許覆蓋 \n 否則 ❌ \n 🏁 以後的正確習慣（很重要） \n 從現在開始： \n 🟢 只在 1a-ag2 寫程式 \n 🟢 push 的對象只有 Classroom \n ❌ 不要再從個人 repo 開發 \n 如果你想保留個人 repo： \n git push personal main \n （反方向同步，用來備份） \n ✅ 一句話總結（你可以記這句） \n 把「個人 repo」當來源，用 fetch + merge 合併到「Classroom repo」一次，之後只用 Classroom。 \n', 'tags': '', 'url': '我的作法.html'}, {'title': '後來大家都要編輯需要中止同步', 'text': '我: \n 我現在想要把我倉儲的跟我個人的倉儲都獨立成個體(取消我個人網站是主要，分組網站是備份)該怎麼做? \n AI: \n 我們現在要做的是把： \n ❌「一個 repo 推兩個 remote（主＋備）」 改成 ✅「兩個完全獨立、互不影響的倉儲」 \n 我會給你 安全、可逆、一步一步 的做法。 \n 🎯 你的目標（確認） 最終你要的是： \n 倉儲 狀態 個人倉儲 LanChienEn/w11 獨立開發 Classroom 倉儲 mdecp2025/1a-ag2 獨立開發 ❌ 不再互相 push 完全切斷 ✅ 正確作法（「切斷關係」只做一次） 🔹 Step 1：確認你現在在哪個資料夾（很重要） 你現在應該在： \n Y:\\w11 確認： \n cd Y:\\w11 git remote -v 你會看到類似： \n origin https://github.com/LanChienEn/w11.git backup https://github.com/mdecp2025/1a-ag2.git 🔹 Step 2：移除 Classroom 的 remote（關鍵） 在 Y:\\w11 執行： \n git remote remove backup 確認： \n git remote -v 只剩： \n origin https://github.com/LanChienEn/w11.git 👉 到這裡：w11 本地專案已「只屬於個人倉儲」 \n 🔹 Step 3：讓 Classroom 倉儲也成為「自己的獨立個體」 ⚠️ 重要觀念 Y:\\1a-ag2 這個資料夾 已經是一個獨立 clone 我們只要確保它： \n 沒有連到你的個人倉儲 \n 只 push Classroom 自己 \n 進入它： \n cd Y:\\1a-ag2 git remote -v 你應該只看到： \n origin https://github.com/mdecp2025/1a-ag2.git ❗ 如果你看到 personal / backup 移除它們： \n git remote remove personal git remote remove backup 再確認： \n git remote -v 🎉 完成後的狀態（非常重要） \n 📁 Y:\\w11 \n origin → 個人 GitHub \n 📁 Y:\\1a-ag2 \n origin → Classroom GitHub 👉 兩個 repo 再也不會互相影響 \n 🧠 之後你要怎麼用？（使用規則） 🧑\u200d💻 開發個人網站 \n cd Y:\\w11 git add . git commit -m "個人網站更新" git push origin main 👥 開發分組/Classroom 網站 \n cd Y:\\1a-ag2 git add . git commit -m "分組網站更新" git push origin main ❌ 不再有 push 兩次 ❌ 不再有主/備概念 \n 🔥 常見錯誤（避免） 錯誤 後果 在 w11 push Classroom 再次混在一起 用 --force Classroom 歷史會壞 兩個 repo 混著改 容易誤 push 🧪 快速檢查清單（考前 10 秒） 在任何資料夾只做這件事： \n git remote -v 看到 一個 origin \n URL 正確 \n 就是「獨立乾淨狀態」✔️ \n \n', 'tags': '', 'url': '後來大家都要編輯需要中止同步.html'}, {'title': '以後只要小組成員要編輯', 'text': '1.就在團體倉儲 開\xa0Codespaces 進到\xa0fluffy sniffle  這個專案裡。 \n 2.在  init_replit 裡輸入pip install flask flask_cors bs4 lxml pelican markdown gevent \n 3.執行後 再輸入 python main.py&   \n 4.在 終端機 的地方就會出現本網頁的網址 \n 5.編輯的頁面輸入首頁第一行密碼即可進入編輯畫面 \n', 'tags': '', 'url': '以後只要小組成員要編輯.html'}, {'title': 'w12', 'text': '', 'tags': '', 'url': 'w12.html'}, {'title': '國旗旋轉', 'text': '(複製到首頁下Brython指令區) \n ________________________________________________________________________ \n # 畫中華民國國旗，並展示 90 度與 45 度順時針旋轉 # 導入 doc from browser import document as doc # 以下將利用 html 產生所需的繪圖畫布 from browser import html # 利用 math 函式庫執行三角函數運算 import math \n # --- 畫布與環境設定 --- \n # 定義畫布尺寸 FLAG_W = 600 FLAG_H = 400 # 旋轉中心點 CENTER_X = FLAG_W / 2 CENTER_Y = FLAG_H / 2 \n # 將畫布添加到 id 為 brython_div1 的 HTML 元素中 brython_div = doc["brython_div1"] \n # 創建標籤和畫布 brython_div <= html.H3("原始國旗 (600x400)") canvas_orig = html.CANVAS(width = FLAG_W, height = FLAG_H, id = "flag_orig", style = {"border": "1px solid #ccc"}) brython_div <= canvas_orig \n brython_div <= html.H3("順時針旋轉 90 度") canvas_90 = html.CANVAS(width = FLAG_W, height = FLAG_H, id = "flag_90", style = {"border": "1px solid #ccc"}) brython_div <= canvas_90 \n brython_div <= html.H3("順時針旋轉 45 度") canvas_45 = html.CANVAS(width = FLAG_W, height = FLAG_H, id = "flag_45", style = {"border": "1px solid #ccc"}) brython_div <= canvas_45 \n # --- 核心繪圖函數 (國旗內容) --- def draw_flag_content(ctx):  """繪製未旋轉狀態的國旗內容，所有座標都是基於 (0, 0) 起點"""  flag_w = FLAG_W  flag_h = FLAG_H    # 青天白日圖案的中心座標 (位於左上四分之一處)  circle_x = flag_w/4  circle_y = flag_h/4  star_radius = flag_w/8 # 白日光芒半徑 \n # 1. 滿地紅 (Red Earth)  ctx.fillStyle=\'rgb(255, 0, 0)\'  ctx.fillRect(0,0,flag_w,flag_h) \n # 2. 青天 (Blue Sky)  ctx.fillStyle=\'rgb(0, 0, 150)\'  ctx.fillRect(0,0,flag_w/2,flag_h/2) \n # 3. 十二道光芒白日 (White Sun with Twelve Rays) - 採用原程式碼邏輯  ctx.beginPath()  angle = 0  for i in range(24):  # 採用原始程式碼中不常見的角度步進，確保旋轉前後形狀一致  angle += 5*math.pi*2/12   toX = circle_x + math.cos(angle)*star_radius  toY = circle_y + math.sin(angle)*star_radius  if (i):  ctx.lineTo(toX, toY)  else:  ctx.moveTo(toX, toY)  ctx.closePath()  ctx.fillStyle = \'#fff\'  ctx.fill() \n # 4. 白日:藍圈 (Blue Ring)  ctx.beginPath()  # 原始半徑: flag_w * 17 / 240  ctx.arc(circle_x, circle_y, flag_w*17/240, 0, math.pi*2, True)  ctx.closePath()  ctx.fillStyle = \'rgb(0, 0, 149)\'  ctx.fill() \n # 5. 白日:白心 (White Center)  ctx.beginPath()  # 原始半徑: flag_w / 16  ctx.arc(circle_x, circle_y, flag_w/16, 0, math.pi*2, True)  ctx.closePath()  ctx.fillStyle = \'#fff\'  ctx.fill() \n # --- 繪製函數：原始國旗 --- def draw_original_flag():  ctx = doc["flag_orig"].getContext("2d")  draw_flag_content(ctx) \n # --- 繪製函數：順時針旋轉 90 度 --- def draw_90_degree_flag():  ctx = doc["flag_90"].getContext("2d")    # 1. 儲存當前狀態  ctx.save()    # 2. 平移原點到畫布中心 (600/2, 400/2) = (300, 200)  ctx.translate(CENTER_X, CENTER_Y)    # 3. 旋轉 90 度 (π/2) 順時針  ctx.rotate(math.pi / 2)    # 4. 將原點平移回去，以便國旗內容以 (0, 0) 為起點繪製  ctx.translate(-CENTER_X, -CENTER_Y)    # 5. 繪製國旗內容  draw_flag_content(ctx)    # 6. 恢復狀態  ctx.restore() \n # --- 繪製函數：順時針旋轉 45 度 --- def draw_45_degree_flag():  ctx = doc["flag_45"].getContext("2d")    # 1. 儲存當前狀態  ctx.save()    # 2. 平移原點到畫布中心  ctx.translate(CENTER_X, CENTER_Y)    # 3. 旋轉 45 度 (π/4) 順時針  ctx.rotate(math.pi / 4)    # 4. 將原點平移回去  ctx.translate(-CENTER_X, -CENTER_Y)    # 5. 繪製國旗內容  draw_flag_content(ctx)    # 6. 恢復狀態  ctx.restore() \n # --- 執行繪圖 --- draw_original_flag() draw_90_degree_flag() draw_45_degree_flag() \n', 'tags': '', 'url': '國旗旋轉.html'}, {'title': '機器人七段程式碼', 'text': '(複製到首頁下Brython指令區) \n ________________________________________________________________________ \n #請修正以下程式讓機器人可以走出七段顯示器格式的數字 from robot_lib import World as BaseWorld, AnimatedRobot as BaseRobot, timer, CELL_SIZE \n # --- 1. 定義世界（加入細格） --- class MyWorld(BaseWorld):  def __init__(self, width=10, height=10, sub_cell=5):  super().__init__(width, height)  self.sub_cell = sub_cell  self.sub_size = CELL_SIZE // sub_cell  self._draw_fine_grid() \n def _draw_fine_grid(self):  ctx = self.layers["grid"].getContext("2d")  ctx.strokeStyle = "#e0e0e0"  ctx.lineWidth = 0.5  # 畫垂直細線  for i in range(self.width * self.sub_cell + 1):  x = i * self.sub_size  ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, self.height * CELL_SIZE); ctx.stroke()  # 畫水平細線  for j in range(self.height * self.sub_cell + 1):  y = j * self.sub_size  ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(self.width * CELL_SIZE, y); ctx.stroke() \n # 細格座標轉換為像素座標  def sub_to_px(self, sub_x, sub_y):  big_x = sub_x // self.sub_cell  big_y = sub_y // self.sub_cell  offset_x = (sub_x % self.sub_cell) * self.sub_size    # 修正點 1: 反轉細格內 Y 偏移量 (oy)，使 sub_y 越大 (往下)，py 越大 (螢幕上往下)。  # 這確保了我們將 (sub_x, sub_y) 視為 Y 軸向下增加的網格座標。  sub_y_offset = sub_y % self.sub_cell  offset_y = (self.sub_cell - 1 - sub_y_offset) * self.sub_size    px = big_x * CELL_SIZE + offset_x + self.sub_size // 2    # BaseWorld 的 Y 軸是從下往上。  # 總像素 Y 座標 (py) 仍然需要反轉 big_y，以匹配螢幕座標（Y 軸向下）。  py = (self.height - 1 - big_y) * CELL_SIZE + offset_y + self.sub_size // 2  return px, py \n # 在細格座標上畫線  def draw_line(self, x1, y1, x2, y2):  ctx = self.layers["objects"].getContext("2d")  ctx.strokeStyle = "#d33"  ctx.lineWidth = 9  ctx.lineCap = "round"  ctx.beginPath()  ctx.moveTo(*self.sub_to_px(x1, y1))  ctx.lineTo(*self.sub_to_px(x2, y2))  ctx.stroke() \n # --- 2. 定義機器人（以細格移動） --- class MyRobot(BaseRobot):  def __init__(self, world, start_big_x=1, start_big_y=1):  super().__init__(world, start_big_x, start_big_y)  # 初始位置轉換為細格中心  self.sub_x = start_big_x * world.sub_cell + world.sub_cell // 2  self.sub_y = start_big_y * world.sub_cell + world.sub_cell // 2  self.robot_size = world.sub_size * 1.8 \n # 重新繪製機器人（使用細格座標）  def _draw_robot(self):  self.robot_ctx.clearRect(0, 0, self.world.width * CELL_SIZE, self.world.height * CELL_SIZE)  img = self.images[self.facing]  px, py = self.world.sub_to_px(self.sub_x, self.sub_y)  s = self.robot_size  if img.complete:  self.robot_ctx.drawImage(img, px - s//2, py - s//2, s, s) \n # 瞬間移動（不畫線）  def teleport_to(self, tx, ty):  def action(done):  self.sub_x, self.sub_y = tx, ty  self._draw_robot()  timer.set_timeout(done, 10)  self.queue.append(action)  self._run_queue() \n # 移動 + 畫線（最核心）  def move_to(self, tx, ty, draw_trace=True):  def action(done):  def step():  if self.sub_x == tx and self.sub_y == ty:  done(); return  prev_x, prev_y = self.sub_x, self.sub_y \n # 計算方向並轉向 (維持原始程式的邏輯，因其主要修正點不在這裡)  dx = tx - self.sub_x  dy = ty - self.sub_y  if dx > 0: target = "E"  elif dx < 0: target = "W"  elif dy > 0: target = "N"  else: target = "S" \n # 同步轉向（安全版）  while self.facing != target:  idx = self.facing_order.index(self.facing)  self.facing = self.facing_order[(idx + 1) % 4] \n # 移動一步  self.sub_x += 1 if dx > 0 else (-1 if dx < 0 else 0)  self.sub_y += 1 if dy > 0 else (-1 if dy < 0 else 0) \n if draw_trace:  self.world.draw_line(prev_x, prev_y, self.sub_x, self.sub_y)  self._draw_robot()  # 調整速度，讓線條更平滑  timer.set_timeout(step, 40)  step()  self.queue.append(action)  self._run_queue() \n # --- 3. 七段顯示器定義 --- SEGMENTS = {  0:[1,1,1,1,1,1,0], 1:[0,1,1,0,0,0,0], 2:[1,1,0,1,1,0,1],  3:[1,1,1,1,0,0,1], 4:[0,1,1,0,0,1,1], 5:[1,0,1,1,0,1,1],  6:[1,0,1,1,1,1,1], 7:[1,1,1,0,0,0,0], 8:[1,1,1,1,1,1,1],  9:[1,1,1,1,0,1,1] } \n # 每個線段的細格座標路徑（相對座標） # 七段顯示器結構是相對座標，高度 7 細格 (0-6)，寬度 4 細格 (0-3)。 # 這裡定義的 PATHS 仍是 Y 軸向下增加 (Y=0 頂部, Y=6 底部) PATHS = [  [(0,0),(1,0),(2,0),(3,0)], # A 上 (Y=0)  [(3,0),(3,1),(3,2),(3,3)], # B 右上  [(3,3),(3,4),(3,5),(3,6)], # C 右下  [(3,6),(2,6),(1,6),(0,6)], # D 下 (Y=6)  [(0,6),(0,5),(0,4),(0,3)], # E 左下  [(0,3),(0,2),(0,1),(0,0)], # F 左上  [(0,3),(1,3),(2,3),(3,3)] # G 中 (Y=3) ] \n def draw_digit(robot, digit, ox, oy):  # 修正點 2: 引入七段顯示器的高度 (最大 Y 座標)  SEGMENT_HEIGHT = 6  if digit not in SEGMENTS: return    for i, on in enumerate(SEGMENTS[digit]):  if not on: continue  path = PATHS[i]    # 修正點 3: 進行 Y 座標反轉：y_fixed = oy + (SEGMENT_HEIGHT - relative_y)  # 將 Y 軸向下增加的相對座標 (0-6) 轉換為 Y 軸向上增加的繪圖座標。    # 初始位置  start_x = ox + path[0][0]  start_y = oy + (SEGMENT_HEIGHT - path[0][1]) # 關鍵反轉  robot.teleport_to(start_x, start_y)    for j in range(1, len(path)):  tx = ox + path[j][0]  ty = oy + (SEGMENT_HEIGHT - path[j][1]) # 關鍵反轉  robot.move_to(tx, ty, draw_trace=True) \n # ==================== 主程式：畫 0123456789 ==================== # 修正 World 寬度，以容納 10 個數字 (10 * 6 寬度 + 邊距) world = MyWorld(65, 10, sub_cell=5)  # 將機器人起始點設在細格 (0, 0) 附近 robot = MyRobot(world, 0, 0) \n # Y 軸偏移量 oy： START_Y_SUB_CELL = 1 \n for i in range(10):  # 每個數字的起始 X 細格座標 (每個數字寬度 4，間隔 2，共 6 寬度)  start_x_offset = 1 + i * 6   draw_digit(robot, i, start_x_offset, START_Y_SUB_CELL) \n print("機器人正在寫字：0123456789 (已修正座標反轉問題)") \n ________________________________________________________________________ \n', 'tags': '', 'url': '機器人七段程式碼.html'}, {'title': '期末報告1(w14三個操作)', 'text': '', 'tags': '', 'url': '期末報告1(w14三個操作).html'}, {'title': '操作一、操作二', 'text': '影片: https://youtu.be/HyKCpGbWiek \n', 'tags': '', 'url': '操作一、操作二.html'}, {'title': '第二個程式的執行', 'text': '影片: https://youtu.be/gs6Zbh4u41A \n', 'tags': '', 'url': '第二個程式的執行.html'}, {'title': '第三個憤怒鳥小遊戲', 'text': '影片: https://youtu.be/Mebi7DRFnMc \n', 'tags': '', 'url': '第三個憤怒鳥小遊戲.html'}, {'title': '期末報告2(程式新功能)', 'text': '', 'tags': '', 'url': '期末報告2(程式新功能).html'}, {'title': '第二個程式的改良', 'text': '以下是第二個程式的原始碼分析: \n 一、整體架構總覽 \n 這是一個：Flask 網頁 + Brython 寫的點擊小遊戲 + Ajax 上傳分數 \n 📌 技術角色分工： \n 技術 用途 Flask 後端伺服器、分數儲存 Jinja2 HTML 模板引擎 Brython 在瀏覽器執行 Python JavaScript (Ajax) 非同步送分數 HTML / CSS 遊戲畫面 \n 二、Jinja2 模板結構說明 \n {% extends "base.html" %} \n 🔹 繼承 base.html \n 使用 Flask 常見的 模板繼承 \n base.html 通常包含： \n <html> \n <head> \n 導覽列 \n 共用 CSS {% block title %}Brython 遊戲{% endblock %} 🔹 設定頁面標題 對應 base.html 裡的 {% block title %} \n 瀏覽器標題顯示「Brython 遊戲」 \n {% block content %} ... {% endblock %} 🔹 主內容區 整個遊戲畫面都在這個區塊內 \n \n 三、載入 Brython \n <script src="https://cdn.jsdelivr.net/npm/brython@3.11.3/brython.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/brython@3.11.3/brython_stdlib.js"></script> 🔹 這兩個做什麼？ 檔案 功能 brython.min.js Brython 核心 brython_stdlib.js Python 標準函式庫 📌 沒有它們，瀏覽器看不懂 <script type="text/python"> \n <body onload="brython(1)"> 🔹 啟動 Brython 網頁載入完成 → 啟動 Brython \n 1 代表「debug 模式」 \n \n 四、遊戲畫面 HTML \n <h2 style="text-align: center;">🕹️ 點擊測試：點擊移動中的圓形！</h2> ➡️ 遊戲標題 \n <div id="brython_div1" style="width: 600px; height: 400px; margin: 20px auto;"></div> 🔹 遊戲場地 寬：600px \n 高：400px \n 所有遊戲元素都動態加到這裡 \n \n 五、為什麼要用 {% raw %}？ \n {% raw %} <script type="text/python"> 🔹 解決的問題 Brython 裡有： \n f"{score}" \n {} \n ⚠️ Jinja2 會誤以為是模板語法 \n ➡️ {% raw %} 告訴 Jinja2：「這一段我不解析，原封不動交給瀏覽器」 \n \n 六、Brython：匯入模組 \n from browser import document, timer, window, ajax import random import time 🔹 每個模組用途 模組 功能 document 操作 DOM timer setTimeout / setInterval window JS 的 window ajax Ajax 請求 random 隨機位置、顏色 time 計時 \n 七、遊戲全域設定 \n GAME_DURATION = 30 score = 0 game_active = False 變數 說明 GAME_DURATION 遊戲時間（秒） score 玩家分數 game_active 是否進行中 \n 八、初始化遊戲區（DOM 操作） \n game_area = document["brython_div1"] ➡️ 抓取 <div id="brython_div1"> \n game_area.style.border = "3px solid #333" game_area.style.backgroundColor = "#e0e0ff" game_area.style.position = "relative" \n 🔹 為什麼要 position: relative？ \n 👉 讓裡面的圓形可以用 absolute 定位 \n \n 九、分數與時間顯示區 \n score_display = document.createElement("div") timer_display = document.createElement("div") 左上角：分數 \n 右上角：倒數時間 \n 📌 這些都是 動態建立的 DOM 元素 \n 十、目標圓形（遊戲核心） \n target = document.createElement("div") target.style.width = "50px" target.style.height = "50px" target.style.borderRadius = "50%" ➡️ 一個 50×50 的圓形 \n target.style.transition = "top 0.3s, left 0.3s" ➡️ 平滑移動動畫 \n \n 十一、移動圓形 \n def move_target(): 🔹 功能流程 檢查遊戲是否進行中 \n 計算最大可移動範圍 \n 隨機產生新位置 \n 隨機顏色 \n 更新 top / left \n 📌 min_y = 40 → 避免蓋住上方分數欄 \n \n 十二、點擊事件 \n @target.bind("click") def hit_target(event): 🔹 這裡很重要！ 只有點到圓形才會觸發 \n 不用額外計算距離 \n 流程： \n 分數 +1 \n 更新顯示 \n 圓形立即移動 \n stopPropagation() 防止事件冒泡 \n \n 十三、Ajax 上傳分數（Brython → Flask） \n req.open(\'POST\', \'{{ url_for("submit_score") }}\', True) \n 🔹 為什麼要 {% endraw %}？ \n url_for() 必須由 Jinja2 處理 \n Brython 不認得 Flask \n 👉 這是 Flask + Brython 混用的標準寫法 \n json_payload = window.JSON.stringify({\'score\': final_score}) req.send(json_payload) ➡️ 送出 JSON： \n { "score": 15 } \n 十四、倒數計時與遊戲結束 \n def check_time(): 每秒執行： \n 計算剩餘時間 \n 時間到： \n 停止遊戲 \n 上傳分數 \n 顯示結束畫面 \n 清除移動計時器 \n \n 十五、重新開始 \n def restart_game(event): 隱藏結束畫面 \n 重新初始化遊戲 \n \n 十六、遊戲啟動流程 \n def start_game(): score = 0 game_active = True check_time() move_target() timer.set_interval(move_target, 800) 📌 啟動時會： \n 分數歸零 \n 啟動倒數 \n 每 0.8 秒移動一次圓形 \n start_game() ➡️ 網頁一打開就開始遊戲 🎮 \n', 'tags': '', 'url': '第二個程式的改良.html'}, {'title': '我所添加的程式新功能', 'text': '', 'tags': '', 'url': '我所添加的程式新功能.html'}, {'title': '改成 Aim Lab 風格', 'text': '\n Aim Lab 風格的重點項目說明 深色背景 專注、低干擾 單一目標 一次只出現一個圓 快速生成 點中立刻生成新目標 固定顏色 通常是亮色（紅 / 綠） 命中回饋 命中變色 / 閃爍 統計數據 命中數、命中率、反應時間 訓練感 不是「遊戲」，是「練準度」 二、你原本程式 → Aim Lab 風格的修改重點 \n', 'tags': '', 'url': '改成 Aim Lab 風格.html'}, {'title': '主要改動', 'text': '背景改深色 \n 移除自動移動 \n 點中才生成新目標 \n 記錄反應時間 \n 顯示 Accuracy（命中率） \n 簡化動畫（快、乾脆） \n', 'tags': '', 'url': '主要改動.html'}, {'title': '以下是原程式為基底的完整改寫版', 'text': '✅ Aim Lab Style Brython Game（Flask + Jinja2） {% extends "base.html" %} \n {% block title %}Aim Lab - Precision Training{% endblock %} \n {% block content %} <script src="https://cdn.jsdelivr.net/npm/brython@3.11.3/brython.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/brython@3.11.3/brython_stdlib.js"></script> \n <body onload="brython(1)"> \n <h2 style="text-align:center;color:white;"> 🎯 Aim Lab – Precision Training </h2> \n <div id="brython_div1"></div> \n {% raw %} <script type="text/python"> from browser import document, timer, window, ajax import random, time \n # ============================= # Aim Lab 訓練設定 # ============================= GAME_DURATION = 30 TARGET_SIZE = 50 \n score = 0 shots = 0 game_active = False spawn_time = 0 reaction_times = [] \n # ============================= # 遊戲場地 # ============================= game_area = document["brython_div1"] game_area.style.width = "700px" game_area.style.height = "450px" game_area.style.margin = "20px auto" game_area.style.border = "2px solid #555" game_area.style.backgroundColor = "#111" game_area.style.position = "relative" game_area.style.cursor = "crosshair" game_area.style.overflow = "hidden" \n # ============================= # UI 顯示 # ============================= hud = document.createElement("div") hud.style.position = "absolute" hud.style.top = "10px" hud.style.left = "10px" hud.style.color = "#0f0" hud.style.fontFamily = "monospace" hud.style.fontSize = "1.1em" game_area <= hud \n timer_display = document.createElement("div") timer_display.style.position = "absolute" timer_display.style.top = "10px" timer_display.style.right = "10px" timer_display.style.color = "#0f0" timer_display.style.fontFamily = "monospace" timer_display.style.fontSize = "1.1em" game_area <= timer_display \n # ============================= # 目標 # ============================= target = document.createElement("div") target.style.width = f"{TARGET_SIZE}px" target.style.height = f"{TARGET_SIZE}px" target.style.borderRadius = "50%" target.style.backgroundColor = "#ff3b3b" target.style.position = "absolute" target.style.display = "none" game_area <= target \n # ============================= # 核心邏輯 # ============================= def spawn_target(): global spawn_time max_x = game_area.clientWidth - TARGET_SIZE max_y = game_area.clientHeight - TARGET_SIZE \n x = random.randint(0, max_x) y = random.randint(40, max_y) \n target.style.left = f"{x}px" target.style.top = f"{y}px" target.style.display = "block" \n spawn_time = time.time() \n @target.bind("click") def hit(event): global score, shots \n if not game_active: return \n score += 1 shots += 1 \n reaction = time.time() - spawn_time reaction_times.append(reaction) \n target.style.display = "none" spawn_target() \n update_hud() event.stopPropagation() \n @game_area.bind("click") def miss(event): global shots if not game_active: return shots += 1 update_hud() \n def update_hud(): accuracy = (score / shots * 100) if shots else 0 avg_reaction = (sum(reaction_times) / len(reaction_times)) if reaction_times else 0 \n hud.text = ( f"Hits: {score} " f"Shots: {shots} " f"Accuracy: {accuracy:.1f}% " f"Avg RT: {avg_reaction*1000:.0f}ms" ) \n # ============================= # 計時 # ============================= def check_time(): global game_active \n remain = int(end_time - time.time()) if remain <= 0: game_active = False target.style.display = "none" timer_display.text = "TIME UP" \n submit_score() return \n timer_display.text = f"{remain}s" timer.set_timeout(check_time, 1000) \n # ============================= # 上傳分數 # ============================= def submit_score(): data = { "score": score, "shots": shots, "accuracy": score / shots if shots else 0 } \n req = ajax.ajax() req.open("POST", "{{ url_for(\'submit_score\') }}", True) req.set_header("Content-Type", "application/json") req.send(window.JSON.stringify(data)) \n # ============================= # 開始遊戲 # ============================= def start_game(): global score, shots, reaction_times, end_time, game_active \n score = 0 shots = 0 reaction_times = [] game_active = True \n end_time = time.time() + GAME_DURATION update_hud() spawn_target() check_time() \n start_game() </script> {% endraw %} \n </body> {% endblock %} \n \n', 'tags': '', 'url': '以下是原程式為基底的完整改寫版.html'}]};